{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValidRoutingTable = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar _a = neo4j_driver_core_1.internal.constants,\n  WRITE = _a.ACCESS_MODE_WRITE,\n  READ = _a.ACCESS_MODE_READ,\n  ServerAddress = neo4j_driver_core_1.internal.serverAddress.ServerAddress;\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar MIN_ROUTERS = 1;\n/**\n * The routing table object used to determine the role of the servers in the driver.\n */\nvar RoutingTable = /** @class */function () {\n  function RoutingTable(_a) {\n    var _b = _a === void 0 ? {} : _a,\n      database = _b.database,\n      routers = _b.routers,\n      readers = _b.readers,\n      writers = _b.writers,\n      expirationTime = _b.expirationTime,\n      ttl = _b.ttl;\n    this.database = database || null;\n    this.databaseName = database || 'default database';\n    this.routers = routers || [];\n    this.readers = readers || [];\n    this.writers = writers || [];\n    this.expirationTime = expirationTime || (0, neo4j_driver_core_1.int)(0);\n    this.ttl = ttl;\n  }\n  /**\n   * Create a valid routing table from a raw object\n   *\n   * @param {string} database the database name. It is used for logging purposes\n   * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n   * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n   * @param {RoutingTable} The valid Routing Table\n   */\n  RoutingTable.fromRawRoutingTable = function (database, routerAddress, rawRoutingTable) {\n    return createValidRoutingTable(database, routerAddress, rawRoutingTable);\n  };\n  RoutingTable.prototype.forget = function (address) {\n    // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,\n    // just remove it from the set of readers and writers, so that we don't use it for actual work without\n    // performing discovery first.\n    this.readers = removeFromArray(this.readers, address);\n    this.writers = removeFromArray(this.writers, address);\n  };\n  RoutingTable.prototype.forgetRouter = function (address) {\n    this.routers = removeFromArray(this.routers, address);\n  };\n  RoutingTable.prototype.forgetWriter = function (address) {\n    this.writers = removeFromArray(this.writers, address);\n  };\n  /**\n   * Check if this routing table is fresh to perform the required operation.\n   * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.\n   * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.\n   */\n  RoutingTable.prototype.isStaleFor = function (accessMode) {\n    return this.expirationTime.lessThan(Date.now()) || this.routers.length < MIN_ROUTERS || accessMode === READ && this.readers.length === 0 || accessMode === WRITE && this.writers.length === 0;\n  };\n  /**\n   * Check if this routing table is expired for specified amount of duration\n   *\n   * @param {Integer} duration amount of duration in milliseconds to check for expiration\n   * @returns {boolean}\n   */\n  RoutingTable.prototype.isExpiredFor = function (duration) {\n    return this.expirationTime.add(duration).lessThan(Date.now());\n  };\n  RoutingTable.prototype.allServers = function () {\n    return __spreadArray(__spreadArray(__spreadArray([], __read(this.routers), false), __read(this.readers), false), __read(this.writers), false);\n  };\n  RoutingTable.prototype.toString = function () {\n    return 'RoutingTable[' + (\"database=\" + this.databaseName + \", \") + (\"expirationTime=\" + this.expirationTime + \", \") + (\"currentTime=\" + Date.now() + \", \") + (\"routers=[\" + this.routers + \"], \") + (\"readers=[\" + this.readers + \"], \") + (\"writers=[\" + this.writers + \"]]\");\n  };\n  return RoutingTable;\n}();\nexports.default = RoutingTable;\n/**\n * Remove all occurrences of the element in the array.\n * @param {Array} array the array to filter.\n * @param {Object} element the element to remove.\n * @return {Array} new filtered array.\n */\nfunction removeFromArray(array, element) {\n  return array.filter(function (item) {\n    return item.asKey() !== element.asKey();\n  });\n}\n/**\n * Create a valid routing table from a raw object\n *\n * @param {string} db the database name. It is used for logging purposes\n * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n * @param {RoutingTable} The valid Routing Table\n */\nfunction createValidRoutingTable(database, routerAddress, rawRoutingTable) {\n  var ttl = rawRoutingTable.ttl;\n  var expirationTime = calculateExpirationTime(rawRoutingTable, routerAddress);\n  var _a = parseServers(rawRoutingTable, routerAddress),\n    routers = _a.routers,\n    readers = _a.readers,\n    writers = _a.writers;\n  assertNonEmpty(routers, 'routers', routerAddress);\n  assertNonEmpty(readers, 'readers', routerAddress);\n  return new RoutingTable({\n    database: database || rawRoutingTable.db,\n    routers: routers,\n    readers: readers,\n    writers: writers,\n    expirationTime: expirationTime,\n    ttl: ttl\n  });\n}\nexports.createValidRoutingTable = createValidRoutingTable;\n/**\n * Parse server from the RawRoutingTable.\n *\n * @param {RawRoutingTable} rawRoutingTable the raw routing table\n * @param {string} routerAddress the router address\n * @returns {Object} The object with the list of routers, readers and writers\n */\nfunction parseServers(rawRoutingTable, routerAddress) {\n  try {\n    var routers_1 = [];\n    var readers_1 = [];\n    var writers_1 = [];\n    rawRoutingTable.servers.forEach(function (server) {\n      var role = server.role;\n      var addresses = server.addresses;\n      if (role === 'ROUTE') {\n        routers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      } else if (role === 'WRITE') {\n        writers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      } else if (role === 'READ') {\n        readers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      }\n    });\n    return {\n      routers: routers_1,\n      readers: readers_1,\n      writers: writers_1\n    };\n  } catch (error) {\n    throw (0, neo4j_driver_core_1.newError)(\"Unable to parse servers entry from router \" + routerAddress + \" from addresses:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable.servers) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n  }\n}\n/**\n * Call the expiration time using the ttls from the raw routing table and return it\n *\n * @param {RawRoutingTable} rawRoutingTable the routing table\n * @param {string} routerAddress the router address\n * @returns {number} the ttl\n */\nfunction calculateExpirationTime(rawRoutingTable, routerAddress) {\n  try {\n    var now = (0, neo4j_driver_core_1.int)(Date.now());\n    var expires = (0, neo4j_driver_core_1.int)(rawRoutingTable.ttl).multiply(1000).add(now);\n    // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n    if (expires.lessThan(now)) {\n      return neo4j_driver_core_1.Integer.MAX_VALUE;\n    }\n    return expires;\n  } catch (error) {\n    throw (0, neo4j_driver_core_1.newError)(\"Unable to parse TTL entry from router \" + routerAddress + \" from raw routing table:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n  }\n}\n/**\n * Assert if serverAddressesArray is not empty, throws and PROTOCOL_ERROR otherwise\n *\n * @param {string[]} serverAddressesArray array of addresses\n * @param {string} serversName the server name\n * @param {string} routerAddress the router address\n */\nfunction assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n  if (serverAddressesArray.length === 0) {\n    throw (0, neo4j_driver_core_1.newError)('Received no ' + serversName + ' from router ' + routerAddress, PROTOCOL_ERROR);\n  }\n}\nfunction parseArray(addresses) {\n  if (!Array.isArray(addresses)) {\n    throw new TypeError('Array expected but got: ' + addresses);\n  }\n  return Array.from(addresses);\n}","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__spreadArray","to","from","pack","arguments","length","l","Array","prototype","slice","concat","Object","defineProperty","exports","createValidRoutingTable","neo4j_driver_core_1","require","_a","internal","constants","WRITE","ACCESS_MODE_WRITE","READ","ACCESS_MODE_READ","ServerAddress","serverAddress","PROTOCOL_ERROR","MIN_ROUTERS","RoutingTable","_b","database","routers","readers","writers","expirationTime","ttl","databaseName","int","fromRawRoutingTable","routerAddress","rawRoutingTable","forget","address","removeFromArray","forgetRouter","forgetWriter","isStaleFor","accessMode","lessThan","Date","now","isExpiredFor","duration","add","allServers","toString","default","array","element","filter","item","asKey","calculateExpirationTime","parseServers","assertNonEmpty","db","routers_1","readers_1","writers_1","servers","forEach","server","role","addresses","parseArray","map","fromUrl","newError","json","stringify","message","expires","multiply","Integer","MAX_VALUE","serverAddressesArray","serversName","isArray","TypeError"],"sources":["C:/Stanford/DigitalTracesApp3/node_modules/neo4j-driver-bolt-connection/lib/rediscovery/routing-table.js"],"sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createValidRoutingTable = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar _a = neo4j_driver_core_1.internal.constants, WRITE = _a.ACCESS_MODE_WRITE, READ = _a.ACCESS_MODE_READ, ServerAddress = neo4j_driver_core_1.internal.serverAddress.ServerAddress;\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar MIN_ROUTERS = 1;\n/**\n * The routing table object used to determine the role of the servers in the driver.\n */\nvar RoutingTable = /** @class */ (function () {\n    function RoutingTable(_a) {\n        var _b = _a === void 0 ? {} : _a, database = _b.database, routers = _b.routers, readers = _b.readers, writers = _b.writers, expirationTime = _b.expirationTime, ttl = _b.ttl;\n        this.database = database || null;\n        this.databaseName = database || 'default database';\n        this.routers = routers || [];\n        this.readers = readers || [];\n        this.writers = writers || [];\n        this.expirationTime = expirationTime || (0, neo4j_driver_core_1.int)(0);\n        this.ttl = ttl;\n    }\n    /**\n     * Create a valid routing table from a raw object\n     *\n     * @param {string} database the database name. It is used for logging purposes\n     * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n     * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n     * @param {RoutingTable} The valid Routing Table\n     */\n    RoutingTable.fromRawRoutingTable = function (database, routerAddress, rawRoutingTable) {\n        return createValidRoutingTable(database, routerAddress, rawRoutingTable);\n    };\n    RoutingTable.prototype.forget = function (address) {\n        // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,\n        // just remove it from the set of readers and writers, so that we don't use it for actual work without\n        // performing discovery first.\n        this.readers = removeFromArray(this.readers, address);\n        this.writers = removeFromArray(this.writers, address);\n    };\n    RoutingTable.prototype.forgetRouter = function (address) {\n        this.routers = removeFromArray(this.routers, address);\n    };\n    RoutingTable.prototype.forgetWriter = function (address) {\n        this.writers = removeFromArray(this.writers, address);\n    };\n    /**\n     * Check if this routing table is fresh to perform the required operation.\n     * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.\n     * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.\n     */\n    RoutingTable.prototype.isStaleFor = function (accessMode) {\n        return (this.expirationTime.lessThan(Date.now()) ||\n            this.routers.length < MIN_ROUTERS ||\n            (accessMode === READ && this.readers.length === 0) ||\n            (accessMode === WRITE && this.writers.length === 0));\n    };\n    /**\n     * Check if this routing table is expired for specified amount of duration\n     *\n     * @param {Integer} duration amount of duration in milliseconds to check for expiration\n     * @returns {boolean}\n     */\n    RoutingTable.prototype.isExpiredFor = function (duration) {\n        return this.expirationTime.add(duration).lessThan(Date.now());\n    };\n    RoutingTable.prototype.allServers = function () {\n        return __spreadArray(__spreadArray(__spreadArray([], __read(this.routers), false), __read(this.readers), false), __read(this.writers), false);\n    };\n    RoutingTable.prototype.toString = function () {\n        return ('RoutingTable[' +\n            (\"database=\" + this.databaseName + \", \") +\n            (\"expirationTime=\" + this.expirationTime + \", \") +\n            (\"currentTime=\" + Date.now() + \", \") +\n            (\"routers=[\" + this.routers + \"], \") +\n            (\"readers=[\" + this.readers + \"], \") +\n            (\"writers=[\" + this.writers + \"]]\"));\n    };\n    return RoutingTable;\n}());\nexports.default = RoutingTable;\n/**\n * Remove all occurrences of the element in the array.\n * @param {Array} array the array to filter.\n * @param {Object} element the element to remove.\n * @return {Array} new filtered array.\n */\nfunction removeFromArray(array, element) {\n    return array.filter(function (item) { return item.asKey() !== element.asKey(); });\n}\n/**\n * Create a valid routing table from a raw object\n *\n * @param {string} db the database name. It is used for logging purposes\n * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n * @param {RoutingTable} The valid Routing Table\n */\nfunction createValidRoutingTable(database, routerAddress, rawRoutingTable) {\n    var ttl = rawRoutingTable.ttl;\n    var expirationTime = calculateExpirationTime(rawRoutingTable, routerAddress);\n    var _a = parseServers(rawRoutingTable, routerAddress), routers = _a.routers, readers = _a.readers, writers = _a.writers;\n    assertNonEmpty(routers, 'routers', routerAddress);\n    assertNonEmpty(readers, 'readers', routerAddress);\n    return new RoutingTable({\n        database: database || rawRoutingTable.db,\n        routers: routers,\n        readers: readers,\n        writers: writers,\n        expirationTime: expirationTime,\n        ttl: ttl\n    });\n}\nexports.createValidRoutingTable = createValidRoutingTable;\n/**\n * Parse server from the RawRoutingTable.\n *\n * @param {RawRoutingTable} rawRoutingTable the raw routing table\n * @param {string} routerAddress the router address\n * @returns {Object} The object with the list of routers, readers and writers\n */\nfunction parseServers(rawRoutingTable, routerAddress) {\n    try {\n        var routers_1 = [];\n        var readers_1 = [];\n        var writers_1 = [];\n        rawRoutingTable.servers.forEach(function (server) {\n            var role = server.role;\n            var addresses = server.addresses;\n            if (role === 'ROUTE') {\n                routers_1 = parseArray(addresses).map(function (address) {\n                    return ServerAddress.fromUrl(address);\n                });\n            }\n            else if (role === 'WRITE') {\n                writers_1 = parseArray(addresses).map(function (address) {\n                    return ServerAddress.fromUrl(address);\n                });\n            }\n            else if (role === 'READ') {\n                readers_1 = parseArray(addresses).map(function (address) {\n                    return ServerAddress.fromUrl(address);\n                });\n            }\n        });\n        return {\n            routers: routers_1,\n            readers: readers_1,\n            writers: writers_1\n        };\n    }\n    catch (error) {\n        throw (0, neo4j_driver_core_1.newError)(\"Unable to parse servers entry from router \" + routerAddress + \" from addresses:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable.servers) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n    }\n}\n/**\n * Call the expiration time using the ttls from the raw routing table and return it\n *\n * @param {RawRoutingTable} rawRoutingTable the routing table\n * @param {string} routerAddress the router address\n * @returns {number} the ttl\n */\nfunction calculateExpirationTime(rawRoutingTable, routerAddress) {\n    try {\n        var now = (0, neo4j_driver_core_1.int)(Date.now());\n        var expires = (0, neo4j_driver_core_1.int)(rawRoutingTable.ttl)\n            .multiply(1000)\n            .add(now);\n        // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n        if (expires.lessThan(now)) {\n            return neo4j_driver_core_1.Integer.MAX_VALUE;\n        }\n        return expires;\n    }\n    catch (error) {\n        throw (0, neo4j_driver_core_1.newError)(\"Unable to parse TTL entry from router \" + routerAddress + \" from raw routing table:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n    }\n}\n/**\n * Assert if serverAddressesArray is not empty, throws and PROTOCOL_ERROR otherwise\n *\n * @param {string[]} serverAddressesArray array of addresses\n * @param {string} serversName the server name\n * @param {string} routerAddress the router address\n */\nfunction assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n    if (serverAddressesArray.length === 0) {\n        throw (0, neo4j_driver_core_1.newError)('Received no ' + serversName + ' from router ' + routerAddress, PROTOCOL_ERROR);\n    }\n}\nfunction parseArray(addresses) {\n    if (!Array.isArray(addresses)) {\n        throw new TypeError('Array expected but got: ' + addresses);\n    }\n    return Array.from(addresses);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}