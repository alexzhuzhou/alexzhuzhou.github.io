{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Unpacker = exports.Packer = void 0;\nvar v1 = __importStar(require(\"./packstream-v1\"));\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar temporal_factory_1 = require(\"./temporal-factory\");\nvar _a = neo4j_driver_core_1.internal.temporalUtil,\n  dateToEpochDay = _a.dateToEpochDay,\n  localDateTimeToEpochSecond = _a.localDateTimeToEpochSecond,\n  localTimeToNanoOfDay = _a.localTimeToNanoOfDay;\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\nvar Packer = /** @class */function (_super) {\n  __extends(Packer, _super);\n  function Packer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Packer.prototype.disableByteArrays = function () {\n    throw new Error('Bolt V2 should always support byte arrays');\n  };\n  Packer.prototype.packable = function (obj) {\n    var _this = this;\n    if ((0, neo4j_driver_core_1.isPoint)(obj)) {\n      return function () {\n        return packPoint(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDuration)(obj)) {\n      return function () {\n        return packDuration(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isLocalTime)(obj)) {\n      return function () {\n        return packLocalTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isTime)(obj)) {\n      return function () {\n        return packTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDate)(obj)) {\n      return function () {\n        return packDate(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isLocalDateTime)(obj)) {\n      return function () {\n        return packLocalDateTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDateTime)(obj)) {\n      return function () {\n        return packDateTime(obj, _this);\n      };\n    } else {\n      return _super.prototype.packable.call(this, obj);\n    }\n  };\n  return Packer;\n}(v1.Packer);\nexports.Packer = Packer;\nvar Unpacker = /** @class */function (_super) {\n  __extends(Unpacker, _super);\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n   */\n  function Unpacker(disableLosslessIntegers, useBigInt) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n    if (useBigInt === void 0) {\n      useBigInt = false;\n    }\n    return _super.call(this, disableLosslessIntegers, useBigInt) || this;\n  }\n  Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n    if (signature === POINT_2D) {\n      return unpackPoint2D(this, structSize, buffer);\n    } else if (signature === POINT_3D) {\n      return unpackPoint3D(this, structSize, buffer);\n    } else if (signature === DURATION) {\n      return unpackDuration(this, structSize, buffer);\n    } else if (signature === LOCAL_TIME) {\n      return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === TIME) {\n      return unpackTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE) {\n      return unpackDate(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === LOCAL_DATE_TIME) {\n      return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\n      return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE_TIME_WITH_ZONE_ID) {\n      return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else {\n      return _super.prototype._unpackUnknownStruct.call(this, signature, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    }\n  };\n  return Unpacker;\n}(v1.Unpacker);\nexports.Unpacker = Unpacker;\n/**\n * Pack given 2D or 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint(point, packer) {\n  var is2DPoint = point.z === null || point.z === undefined;\n  if (is2DPoint) {\n    packPoint2D(point, packer);\n  } else {\n    packPoint3D(point, packer);\n  }\n}\n/**\n * Pack given 2D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint2D(point, packer) {\n  var packableStructFields = [packer.packable((0, neo4j_driver_core_1.int)(point.srid)), packer.packable(point.x), packer.packable(point.y)];\n  packer.packStruct(POINT_2D, packableStructFields);\n}\n/**\n * Pack given 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint3D(point, packer) {\n  var packableStructFields = [packer.packable((0, neo4j_driver_core_1.int)(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];\n  packer.packStruct(POINT_3D, packableStructFields);\n}\n/**\n * Unpack 2D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 2D point value.\n */\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n  return new neo4j_driver_core_1.Point(unpacker.unpack(buffer),\n  // srid\n  unpacker.unpack(buffer),\n  // x\n  unpacker.unpack(buffer),\n  // y\n  undefined // z\n  );\n}\n/**\n * Unpack 3D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 3D point value.\n */\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n  return new neo4j_driver_core_1.Point(unpacker.unpack(buffer),\n  // srid\n  unpacker.unpack(buffer),\n  // x\n  unpacker.unpack(buffer),\n  // y\n  unpacker.unpack(buffer) // z\n  );\n}\n/**\n * Pack given duration.\n * @param {Duration} value the duration value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDuration(value, packer) {\n  var months = (0, neo4j_driver_core_1.int)(value.months);\n  var days = (0, neo4j_driver_core_1.int)(value.days);\n  var seconds = (0, neo4j_driver_core_1.int)(value.seconds);\n  var nanoseconds = (0, neo4j_driver_core_1.int)(value.nanoseconds);\n  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];\n  packer.packStruct(DURATION, packableStructFields);\n}\n/**\n * Unpack duration value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Duration} the unpacked duration value.\n */\nfunction unpackDuration(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n  var months = unpacker.unpack(buffer);\n  var days = unpacker.unpack(buffer);\n  var seconds = unpacker.unpack(buffer);\n  var nanoseconds = unpacker.unpack(buffer);\n  return new neo4j_driver_core_1.Duration(months, days, seconds, nanoseconds);\n}\n/**\n * Pack given local time.\n * @param {LocalTime} value the local time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packLocalTime(value, packer) {\n  var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n  var packableStructFields = [packer.packable(nanoOfDay)];\n  packer.packStruct(LOCAL_TIME, packableStructFields);\n}\n/**\n * Unpack local time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\n * @return {LocalTime} the unpacked local time value.\n */\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given time.\n * @param {Time} value the time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packTime(value, packer) {\n  var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n  var offsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];\n  packer.packStruct(TIME, packableStructFields);\n}\n/**\n * Unpack time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\n * @return {Time} the unpacked time value.\n */\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var offsetSeconds = unpacker.unpackInteger(buffer);\n  var localTime = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n  var result = new neo4j_driver_core_1.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given neo4j date.\n * @param {Date} value the date value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDate(value, packer) {\n  var epochDay = dateToEpochDay(value.year, value.month, value.day);\n  var packableStructFields = [packer.packable(epochDay)];\n  packer.packStruct(DATE, packableStructFields);\n}\n/**\n * Unpack neo4j date value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\n * @return {Date} the unpacked neo4j date value.\n */\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n  var epochDay = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.epochDayToDate)(epochDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given local date time.\n * @param {LocalDateTime} value the local date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packLocalDateTime(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];\n  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\n}\n/**\n * Unpack local date time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\n * @return {LocalDateTime} the unpacked local date time value.\n */\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTime(value, packer) {\n  if (value.timeZoneId) {\n    packDateTimeWithZoneId(value, packer);\n  } else {\n    packDateTimeWithZoneOffset(value, packer);\n  }\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneOffset(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\n * Unpack date time with zone offset value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone offset value.\n */\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneId(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneId = value.timeZoneId;\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneId = unpacker.unpack(buffer);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n  if (!disableLosslessIntegers && !useBigInt) {\n    return obj;\n  }\n  var convert = function convert(value) {\n    return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n  };\n  var clone = Object.create(Object.getPrototypeOf(obj));\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      var value = obj[prop];\n      clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n    }\n  }\n  Object.freeze(clone);\n  return clone;\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__createBinding","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","exports","Unpacker","Packer","v1","require","neo4j_driver_core_1","temporal_factory_1","_a","internal","temporalUtil","dateToEpochDay","localDateTimeToEpochSecond","localTimeToNanoOfDay","POINT_2D","POINT_2D_STRUCT_SIZE","POINT_3D","POINT_3D_STRUCT_SIZE","DURATION","DURATION_STRUCT_SIZE","LOCAL_TIME","LOCAL_TIME_STRUCT_SIZE","TIME","TIME_STRUCT_SIZE","DATE","DATE_STRUCT_SIZE","LOCAL_DATE_TIME","LOCAL_DATE_TIME_STRUCT_SIZE","DATE_TIME_WITH_ZONE_OFFSET","DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE","DATE_TIME_WITH_ZONE_ID","DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE","_super","apply","arguments","disableByteArrays","Error","packable","obj","_this","isPoint","packPoint","isDuration","packDuration","isLocalTime","packLocalTime","isTime","packTime","isDate","packDate","isLocalDateTime","packLocalDateTime","isDateTime","packDateTime","disableLosslessIntegers","useBigInt","_unpackUnknownStruct","signature","structSize","buffer","unpackPoint2D","unpackPoint3D","unpackDuration","unpackLocalTime","_disableLosslessIntegers","_useBigInt","unpackTime","unpackDate","unpackLocalDateTime","unpackDateTimeWithZoneOffset","unpackDateTimeWithZoneId","point","packer","is2DPoint","z","packPoint2D","packPoint3D","packableStructFields","int","srid","x","y","packStruct","unpacker","_verifyStructSize","Point","unpack","months","days","seconds","nanoseconds","Duration","nanoOfDay","hour","minute","second","nanosecond","unpackInteger","nanoOfDayToLocalTime","convertIntegerPropsIfNeeded","offsetSeconds","timeZoneOffsetSeconds","localTime","Time","epochDay","year","month","day","epochDayToDate","epochSecond","nano","epochSecondAndNanoToLocalDateTime","timeZoneId","packDateTimeWithZoneId","packDateTimeWithZoneOffset","localDateTime","DateTime","convert","toBigInt","toNumberOrInfinity","clone","getPrototypeOf","prop","isInt","freeze"],"sources":["C:/Stanford/DigitalTracesApp3/node_modules/neo4j-driver-bolt-connection/lib/packstream/packstream-v2.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Unpacker = exports.Packer = void 0;\nvar v1 = __importStar(require(\"./packstream-v1\"));\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar temporal_factory_1 = require(\"./temporal-factory\");\nvar _a = neo4j_driver_core_1.internal.temporalUtil, dateToEpochDay = _a.dateToEpochDay, localDateTimeToEpochSecond = _a.localDateTimeToEpochSecond, localTimeToNanoOfDay = _a.localTimeToNanoOfDay;\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\nvar Packer = /** @class */ (function (_super) {\n    __extends(Packer, _super);\n    function Packer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Packer.prototype.disableByteArrays = function () {\n        throw new Error('Bolt V2 should always support byte arrays');\n    };\n    Packer.prototype.packable = function (obj) {\n        var _this = this;\n        if ((0, neo4j_driver_core_1.isPoint)(obj)) {\n            return function () { return packPoint(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isDuration)(obj)) {\n            return function () { return packDuration(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isLocalTime)(obj)) {\n            return function () { return packLocalTime(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isTime)(obj)) {\n            return function () { return packTime(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isDate)(obj)) {\n            return function () { return packDate(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isLocalDateTime)(obj)) {\n            return function () { return packLocalDateTime(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isDateTime)(obj)) {\n            return function () { return packDateTime(obj, _this); };\n        }\n        else {\n            return _super.prototype.packable.call(this, obj);\n        }\n    };\n    return Packer;\n}(v1.Packer));\nexports.Packer = Packer;\nvar Unpacker = /** @class */ (function (_super) {\n    __extends(Unpacker, _super);\n    /**\n     * @constructor\n     * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n     * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n     */\n    function Unpacker(disableLosslessIntegers, useBigInt) {\n        if (disableLosslessIntegers === void 0) { disableLosslessIntegers = false; }\n        if (useBigInt === void 0) { useBigInt = false; }\n        return _super.call(this, disableLosslessIntegers, useBigInt) || this;\n    }\n    Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n        if (signature === POINT_2D) {\n            return unpackPoint2D(this, structSize, buffer);\n        }\n        else if (signature === POINT_3D) {\n            return unpackPoint3D(this, structSize, buffer);\n        }\n        else if (signature === DURATION) {\n            return unpackDuration(this, structSize, buffer);\n        }\n        else if (signature === LOCAL_TIME) {\n            return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === TIME) {\n            return unpackTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === DATE) {\n            return unpackDate(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === LOCAL_DATE_TIME) {\n            return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\n            return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === DATE_TIME_WITH_ZONE_ID) {\n            return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else {\n            return _super.prototype._unpackUnknownStruct.call(this, signature, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n    };\n    return Unpacker;\n}(v1.Unpacker));\nexports.Unpacker = Unpacker;\n/**\n * Pack given 2D or 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint(point, packer) {\n    var is2DPoint = point.z === null || point.z === undefined;\n    if (is2DPoint) {\n        packPoint2D(point, packer);\n    }\n    else {\n        packPoint3D(point, packer);\n    }\n}\n/**\n * Pack given 2D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint2D(point, packer) {\n    var packableStructFields = [\n        packer.packable((0, neo4j_driver_core_1.int)(point.srid)),\n        packer.packable(point.x),\n        packer.packable(point.y)\n    ];\n    packer.packStruct(POINT_2D, packableStructFields);\n}\n/**\n * Pack given 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint3D(point, packer) {\n    var packableStructFields = [\n        packer.packable((0, neo4j_driver_core_1.int)(point.srid)),\n        packer.packable(point.x),\n        packer.packable(point.y),\n        packer.packable(point.z)\n    ];\n    packer.packStruct(POINT_3D, packableStructFields);\n}\n/**\n * Unpack 2D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 2D point value.\n */\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n    unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\n    unpacker.unpack(buffer), // x\n    unpacker.unpack(buffer), // y\n    undefined // z\n    );\n}\n/**\n * Unpack 3D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 3D point value.\n */\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n    unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\n    unpacker.unpack(buffer), // x\n    unpacker.unpack(buffer), // y\n    unpacker.unpack(buffer) // z\n    );\n}\n/**\n * Pack given duration.\n * @param {Duration} value the duration value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDuration(value, packer) {\n    var months = (0, neo4j_driver_core_1.int)(value.months);\n    var days = (0, neo4j_driver_core_1.int)(value.days);\n    var seconds = (0, neo4j_driver_core_1.int)(value.seconds);\n    var nanoseconds = (0, neo4j_driver_core_1.int)(value.nanoseconds);\n    var packableStructFields = [\n        packer.packable(months),\n        packer.packable(days),\n        packer.packable(seconds),\n        packer.packable(nanoseconds)\n    ];\n    packer.packStruct(DURATION, packableStructFields);\n}\n/**\n * Unpack duration value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Duration} the unpacked duration value.\n */\nfunction unpackDuration(unpacker, structSize, buffer) {\n    unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n    var months = unpacker.unpack(buffer);\n    var days = unpacker.unpack(buffer);\n    var seconds = unpacker.unpack(buffer);\n    var nanoseconds = unpacker.unpack(buffer);\n    return new neo4j_driver_core_1.Duration(months, days, seconds, nanoseconds);\n}\n/**\n * Pack given local time.\n * @param {LocalTime} value the local time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packLocalTime(value, packer) {\n    var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n    var packableStructFields = [packer.packable(nanoOfDay)];\n    packer.packStruct(LOCAL_TIME, packableStructFields);\n}\n/**\n * Unpack local time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\n * @return {LocalTime} the unpacked local time value.\n */\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n    unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n    var nanoOfDay = unpacker.unpackInteger(buffer);\n    var result = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given time.\n * @param {Time} value the time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packTime(value, packer) {\n    var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n    var offsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n    var packableStructFields = [\n        packer.packable(nanoOfDay),\n        packer.packable(offsetSeconds)\n    ];\n    packer.packStruct(TIME, packableStructFields);\n}\n/**\n * Unpack time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\n * @return {Time} the unpacked time value.\n */\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n    var nanoOfDay = unpacker.unpackInteger(buffer);\n    var offsetSeconds = unpacker.unpackInteger(buffer);\n    var localTime = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n    var result = new neo4j_driver_core_1.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given neo4j date.\n * @param {Date} value the date value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDate(value, packer) {\n    var epochDay = dateToEpochDay(value.year, value.month, value.day);\n    var packableStructFields = [packer.packable(epochDay)];\n    packer.packStruct(DATE, packableStructFields);\n}\n/**\n * Unpack neo4j date value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\n * @return {Date} the unpacked neo4j date value.\n */\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n    var epochDay = unpacker.unpackInteger(buffer);\n    var result = (0, temporal_factory_1.epochDayToDate)(epochDay);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given local date time.\n * @param {LocalDateTime} value the local date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packLocalDateTime(value, packer) {\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n    var packableStructFields = [\n        packer.packable(epochSecond),\n        packer.packable(nano)\n    ];\n    packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\n}\n/**\n * Unpack local date time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\n * @return {LocalDateTime} the unpacked local date time value.\n */\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n    var epochSecond = unpacker.unpackInteger(buffer);\n    var nano = unpacker.unpackInteger(buffer);\n    var result = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTime(value, packer) {\n    if (value.timeZoneId) {\n        packDateTimeWithZoneId(value, packer);\n    }\n    else {\n        packDateTimeWithZoneOffset(value, packer);\n    }\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneOffset(value, packer) {\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n    var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n    var packableStructFields = [\n        packer.packable(epochSecond),\n        packer.packable(nano),\n        packer.packable(timeZoneOffsetSeconds)\n    ];\n    packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\n * Unpack date time with zone offset value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone offset value.\n */\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n    var epochSecond = unpacker.unpackInteger(buffer);\n    var nano = unpacker.unpackInteger(buffer);\n    var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n    var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n    var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneId(value, packer) {\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n    var timeZoneId = value.timeZoneId;\n    var packableStructFields = [\n        packer.packable(epochSecond),\n        packer.packable(nano),\n        packer.packable(timeZoneId)\n    ];\n    packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n    var epochSecond = unpacker.unpackInteger(buffer);\n    var nano = unpacker.unpackInteger(buffer);\n    var timeZoneId = unpacker.unpack(buffer);\n    var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n    var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n    if (!disableLosslessIntegers && !useBigInt) {\n        return obj;\n    }\n    var convert = function (value) {\n        return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n    };\n    var clone = Object.create(Object.getPrototypeOf(obj));\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            var value = obj[prop];\n            clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n        }\n    }\n    Object.freeze(clone);\n    return clone;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}