{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar result_summary_1 = __importDefault(require(\"./result-summary\"));\nvar internal_1 = require(\"./internal\");\nvar EMPTY_CONNECTION_HOLDER = internal_1.connectionHolder.EMPTY_CONNECTION_HOLDER;\n/**\n * @private\n * @param {Error} error The error\n * @returns {void}\n */\nvar DEFAULT_ON_ERROR = function DEFAULT_ON_ERROR(error) {\n  console.log('Uncaught error when processing result: ' + error);\n};\n/**\n * @private\n * @param {ResultSummary} summary\n * @returns {void}\n */\nvar DEFAULT_ON_COMPLETED = function DEFAULT_ON_COMPLETED(summary) {};\n/**\n * A stream of {@link Record} representing the result of a query.\n * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}\n * summary, or rejected with error that contains {@link string} code and {@link string} message.\n * Alternatively can be consumed lazily using {@link Result#subscribe} function.\n * @access public\n */\nvar Result = /** @class */function () {\n  /**\n   * Inject the observer to be used.\n   * @constructor\n   * @access private\n   * @param {Promise<observer.ResultStreamObserver>} streamObserverPromise\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.\n   */\n  function Result(streamObserverPromise, query, parameters, connectionHolder) {\n    this._stack = captureStacktrace();\n    this._streamObserverPromise = streamObserverPromise;\n    this._p = null;\n    this._query = query;\n    this._parameters = parameters || {};\n    this._connectionHolder = connectionHolder || EMPTY_CONNECTION_HOLDER;\n  }\n  /**\n   * Returns a promise for the field keys.\n   *\n   * *Should not be combined with {@link Result#subscribe} function.*\n   *\n   * @public\n   * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.\n   }\n   */\n  Result.prototype.keys = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this._streamObserverPromise.then(function (observer) {\n        return observer.subscribe({\n          onKeys: function onKeys(keys) {\n            return resolve(keys);\n          },\n          onError: function onError(err) {\n            return reject(err);\n          }\n        });\n      }).catch(reject);\n    });\n  };\n  /**\n   * Returns a promise for the result summary.\n   *\n   * *Should not be combined with {@link Result#subscribe} function.*\n   *\n   * @public\n   * @returns {Promise<ResultSummary>} - Result summary.\n   *\n   */\n  Result.prototype.summary = function () {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this._streamObserverPromise.then(function (o) {\n        o.cancel();\n        o.subscribe({\n          onCompleted: function onCompleted(metadata) {\n            return _this._createSummary(metadata).then(resolve, reject);\n          },\n          onError: function onError(err) {\n            return reject(err);\n          }\n        });\n      }).catch(reject);\n    });\n  };\n  /**\n   * Create and return new Promise\n   *\n   * @private\n   * @return {Promise} new Promise.\n   */\n  Result.prototype._getOrCreatePromise = function () {\n    var _this = this;\n    if (!this._p) {\n      this._p = new Promise(function (resolve, reject) {\n        var records = [];\n        var observer = {\n          onNext: function onNext(record) {\n            records.push(record);\n          },\n          onCompleted: function onCompleted(summary) {\n            resolve({\n              records: records,\n              summary: summary\n            });\n          },\n          onError: function onError(error) {\n            reject(error);\n          }\n        };\n        _this.subscribe(observer);\n      });\n    }\n    return this._p;\n  };\n  /**\n   * Waits for all results and calls the passed in function with the results.\n   *\n   * *Should not be combined with {@link Result#subscribe} function.*\n   *\n   * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called\n   * when finished.\n   * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\n   * @return {Promise} promise.\n   */\n  Result.prototype.then = function (onFulfilled, onRejected) {\n    return this._getOrCreatePromise().then(onFulfilled, onRejected);\n  };\n  /**\n   * Catch errors when using promises.\n   *\n   * *Should not be combined with {@link Result#subscribe} function.*\n   *\n   * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\n   * @return {Promise} promise.\n   */\n  Result.prototype.catch = function (onRejected) {\n    return this._getOrCreatePromise().catch(onRejected);\n  };\n  Result.prototype.finally = function (onfinally) {\n    return this._getOrCreatePromise().finally(onfinally);\n  };\n  /**\n   * Stream records to observer as they come in, this is a more efficient method\n   * of handling the results, and allows you to handle arbitrarily large results.\n   *\n   * @param {Object} observer - Observer object\n   * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.\n   * @param {function(record: Record)} observer.onNext - handle records, one by one.\n   * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.\n   * @param {function(error: {message:string, code:string})} observer.onError - handle errors.\n   * @return {void}\n   */\n  Result.prototype.subscribe = function (observer) {\n    var _this = this;\n    var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;\n    var onCompletedWrapper = function onCompletedWrapper(metadata) {\n      _this._createSummary(metadata).then(function (summary) {\n        return onCompletedOriginal.call(observer, summary);\n      });\n    };\n    observer.onCompleted = onCompletedWrapper;\n    var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;\n    var onErrorWrapper = function onErrorWrapper(error) {\n      // notify connection holder that the used connection is not needed any more because error happened\n      // and result can't bee consumed any further; call the original onError callback after that\n      _this._connectionHolder.releaseConnection().then(function () {\n        replaceStacktrace(error, _this._stack);\n        onErrorOriginal.call(observer, error);\n      });\n    };\n    observer.onError = onErrorWrapper;\n    this._streamObserverPromise.then(function (o) {\n      return o.subscribe(observer);\n    }).catch(function (error) {\n      return observer.onError(error);\n    });\n  };\n  /**\n   * Signals the stream observer that the future records should be discarded on the server.\n   *\n   * @protected\n   * @since 4.0.0\n   * @returns {void}\n   */\n  Result.prototype._cancel = function () {\n    this._streamObserverPromise.then(function (o) {\n      return o.cancel();\n    });\n  };\n  Result.prototype._createSummary = function (metadata) {\n    var _a = internal_1.util.validateQueryAndParameters(this._query, this._parameters, {\n        skipAsserts: true\n      }),\n      query = _a.validatedQuery,\n      parameters = _a.params;\n    var connectionHolder = this._connectionHolder;\n    return connectionHolder.getConnection().then(\n    // onFulfilled:\n    function (connection) {\n      return connectionHolder.releaseConnection().then(function () {\n        return connection ? connection.protocol().version : undefined;\n      });\n    },\n    // onRejected:\n    function (_) {\n      return undefined;\n    }).then(function (protocolVersion) {\n      return new result_summary_1.default(query, parameters, metadata, protocolVersion);\n    });\n  };\n  return Result;\n}();\nSymbol.toStringTag;\nfunction captureStacktrace() {\n  var error = new Error('');\n  if (error.stack) {\n    return error.stack.replace(/^Error(\\n\\r)*/, ''); // we don't need the 'Error\\n' part, if only it exists\n  }\n\n  return null;\n}\n/**\n * @private\n * @param {Error} error The error\n * @param {string| null} newStack The newStack\n * @returns {void}\n */\nfunction replaceStacktrace(error, newStack) {\n  if (newStack) {\n    // Error.prototype.toString() concatenates error.name and error.message nicely\n    // then we add the rest of the stack trace\n    error.stack = error.toString() + '\\n' + newStack;\n  }\n}\nexports.default = Result;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","result_summary_1","require","internal_1","EMPTY_CONNECTION_HOLDER","connectionHolder","DEFAULT_ON_ERROR","error","console","log","DEFAULT_ON_COMPLETED","summary","Result","streamObserverPromise","query","parameters","_stack","captureStacktrace","_streamObserverPromise","_p","_query","_parameters","_connectionHolder","prototype","keys","_this","Promise","resolve","reject","then","observer","subscribe","onKeys","onError","err","catch","o","cancel","onCompleted","metadata","_createSummary","_getOrCreatePromise","records","onNext","record","push","onFulfilled","onRejected","finally","onfinally","onCompletedOriginal","onCompletedWrapper","call","onErrorOriginal","onErrorWrapper","releaseConnection","replaceStacktrace","_cancel","_a","util","validateQueryAndParameters","skipAsserts","validatedQuery","params","getConnection","connection","protocol","version","undefined","_","protocolVersion","default","Symbol","toStringTag","Error","stack","replace","newStack","toString"],"sources":["C:/Stanford/DigitalTracesApp3/node_modules/neo4j-driver-core/lib/result.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar result_summary_1 = __importDefault(require(\"./result-summary\"));\nvar internal_1 = require(\"./internal\");\nvar EMPTY_CONNECTION_HOLDER = internal_1.connectionHolder.EMPTY_CONNECTION_HOLDER;\n/**\n * @private\n * @param {Error} error The error\n * @returns {void}\n */\nvar DEFAULT_ON_ERROR = function (error) {\n    console.log('Uncaught error when processing result: ' + error);\n};\n/**\n * @private\n * @param {ResultSummary} summary\n * @returns {void}\n */\nvar DEFAULT_ON_COMPLETED = function (summary) { };\n/**\n * A stream of {@link Record} representing the result of a query.\n * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}\n * summary, or rejected with error that contains {@link string} code and {@link string} message.\n * Alternatively can be consumed lazily using {@link Result#subscribe} function.\n * @access public\n */\nvar Result = /** @class */ (function () {\n    /**\n     * Inject the observer to be used.\n     * @constructor\n     * @access private\n     * @param {Promise<observer.ResultStreamObserver>} streamObserverPromise\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.\n     */\n    function Result(streamObserverPromise, query, parameters, connectionHolder) {\n        this._stack = captureStacktrace();\n        this._streamObserverPromise = streamObserverPromise;\n        this._p = null;\n        this._query = query;\n        this._parameters = parameters || {};\n        this._connectionHolder = connectionHolder || EMPTY_CONNECTION_HOLDER;\n    }\n    /**\n     * Returns a promise for the field keys.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @public\n     * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.\n     }\n     */\n    Result.prototype.keys = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this._streamObserverPromise\n                .then(function (observer) {\n                return observer.subscribe({\n                    onKeys: function (keys) { return resolve(keys); },\n                    onError: function (err) { return reject(err); }\n                });\n            })\n                .catch(reject);\n        });\n    };\n    /**\n     * Returns a promise for the result summary.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @public\n     * @returns {Promise<ResultSummary>} - Result summary.\n     *\n     */\n    Result.prototype.summary = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this._streamObserverPromise\n                .then(function (o) {\n                o.cancel();\n                o.subscribe({\n                    onCompleted: function (metadata) {\n                        return _this._createSummary(metadata).then(resolve, reject);\n                    },\n                    onError: function (err) { return reject(err); }\n                });\n            })\n                .catch(reject);\n        });\n    };\n    /**\n     * Create and return new Promise\n     *\n     * @private\n     * @return {Promise} new Promise.\n     */\n    Result.prototype._getOrCreatePromise = function () {\n        var _this = this;\n        if (!this._p) {\n            this._p = new Promise(function (resolve, reject) {\n                var records = [];\n                var observer = {\n                    onNext: function (record) {\n                        records.push(record);\n                    },\n                    onCompleted: function (summary) {\n                        resolve({ records: records, summary: summary });\n                    },\n                    onError: function (error) {\n                        reject(error);\n                    }\n                };\n                _this.subscribe(observer);\n            });\n        }\n        return this._p;\n    };\n    /**\n     * Waits for all results and calls the passed in function with the results.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called\n     * when finished.\n     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\n     * @return {Promise} promise.\n     */\n    Result.prototype.then = function (onFulfilled, onRejected) {\n        return this._getOrCreatePromise().then(onFulfilled, onRejected);\n    };\n    /**\n     * Catch errors when using promises.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\n     * @return {Promise} promise.\n     */\n    Result.prototype.catch = function (onRejected) {\n        return this._getOrCreatePromise().catch(onRejected);\n    };\n    Result.prototype.finally = function (onfinally) {\n        return this._getOrCreatePromise().finally(onfinally);\n    };\n    /**\n     * Stream records to observer as they come in, this is a more efficient method\n     * of handling the results, and allows you to handle arbitrarily large results.\n     *\n     * @param {Object} observer - Observer object\n     * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.\n     * @param {function(record: Record)} observer.onNext - handle records, one by one.\n     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.\n     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.\n     * @return {void}\n     */\n    Result.prototype.subscribe = function (observer) {\n        var _this = this;\n        var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;\n        var onCompletedWrapper = function (metadata) {\n            _this._createSummary(metadata).then(function (summary) {\n                return onCompletedOriginal.call(observer, summary);\n            });\n        };\n        observer.onCompleted = onCompletedWrapper;\n        var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;\n        var onErrorWrapper = function (error) {\n            // notify connection holder that the used connection is not needed any more because error happened\n            // and result can't bee consumed any further; call the original onError callback after that\n            _this._connectionHolder.releaseConnection().then(function () {\n                replaceStacktrace(error, _this._stack);\n                onErrorOriginal.call(observer, error);\n            });\n        };\n        observer.onError = onErrorWrapper;\n        this._streamObserverPromise\n            .then(function (o) {\n            return o.subscribe(observer);\n        })\n            .catch(function (error) { return observer.onError(error); });\n    };\n    /**\n     * Signals the stream observer that the future records should be discarded on the server.\n     *\n     * @protected\n     * @since 4.0.0\n     * @returns {void}\n     */\n    Result.prototype._cancel = function () {\n        this._streamObserverPromise.then(function (o) { return o.cancel(); });\n    };\n    Result.prototype._createSummary = function (metadata) {\n        var _a = internal_1.util.validateQueryAndParameters(this._query, this._parameters, {\n            skipAsserts: true\n        }), query = _a.validatedQuery, parameters = _a.params;\n        var connectionHolder = this._connectionHolder;\n        return connectionHolder\n            .getConnection()\n            .then(\n        // onFulfilled:\n        function (connection) {\n            return connectionHolder\n                .releaseConnection()\n                .then(function () {\n                return connection ? connection.protocol().version : undefined;\n            });\n        }, \n        // onRejected:\n        function (_) { return undefined; })\n            .then(function (protocolVersion) {\n            return new result_summary_1.default(query, parameters, metadata, protocolVersion);\n        });\n    };\n    return Result;\n}());\nSymbol.toStringTag;\nfunction captureStacktrace() {\n    var error = new Error('');\n    if (error.stack) {\n        return error.stack.replace(/^Error(\\n\\r)*/, ''); // we don't need the 'Error\\n' part, if only it exists\n    }\n    return null;\n}\n/**\n * @private\n * @param {Error} error The error\n * @param {string| null} newStack The newStack\n * @returns {void}\n */\nfunction replaceStacktrace(error, newStack) {\n    if (newStack) {\n        // Error.prototype.toString() concatenates error.name and error.message nicely\n        // then we add the rest of the stack trace\n        error.stack = error.toString() + '\\n' + newStack;\n    }\n}\nexports.default = Result;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}