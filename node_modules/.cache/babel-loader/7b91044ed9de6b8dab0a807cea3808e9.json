{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.floorMod = exports.floorDiv = exports.assertValidNanosecond = exports.assertValidSecond = exports.assertValidMinute = exports.assertValidHour = exports.assertValidDay = exports.assertValidMonth = exports.assertValidYear = exports.timeZoneOffsetInSeconds = exports.totalNanoseconds = exports.dateToIsoString = exports.timeZoneOffsetToIsoString = exports.timeToIsoString = exports.durationToIsoString = exports.dateToEpochDay = exports.localDateTimeToEpochSecond = exports.localTimeToNanoOfDay = exports.normalizeNanosecondsForDuration = exports.normalizeSecondsForDuration = exports.SECONDS_PER_DAY = exports.DAYS_PER_400_YEAR_CYCLE = exports.DAYS_0000_TO_1970 = exports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE = exports.NANOS_PER_MILLISECOND = exports.NANOS_PER_SECOND = exports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE = exports.MINUTES_PER_HOUR = exports.NANOSECOND_OF_SECOND_RANGE = exports.SECOND_OF_MINUTE_RANGE = exports.MINUTE_OF_HOUR_RANGE = exports.HOUR_OF_DAY_RANGE = exports.DAY_OF_MONTH_RANGE = exports.MONTH_OF_YEAR_RANGE = exports.YEAR_RANGE = void 0;\nvar integer_1 = __importStar(require(\"../integer\"));\nvar error_1 = require(\"../error\");\nvar util_1 = require(\"./util\");\n/*\n  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.\n\n  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived\n  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere\n  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.\n\n  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the\n  conversion functions.\n */\nvar ValueRange = /** @class */function () {\n  function ValueRange(min, max) {\n    this._minNumber = min;\n    this._maxNumber = max;\n    this._minInteger = (0, integer_1.int)(min);\n    this._maxInteger = (0, integer_1.int)(max);\n  }\n  ValueRange.prototype.contains = function (value) {\n    if ((0, integer_1.isInt)(value) && value instanceof integer_1.default) {\n      return value.greaterThanOrEqual(this._minInteger) && value.lessThanOrEqual(this._maxInteger);\n    } else if (typeof value === 'bigint') {\n      var intValue = (0, integer_1.int)(value);\n      return intValue.greaterThanOrEqual(this._minInteger) && intValue.lessThanOrEqual(this._maxInteger);\n    } else {\n      return value >= this._minNumber && value <= this._maxNumber;\n    }\n  };\n  ValueRange.prototype.toString = function () {\n    return \"[\" + this._minNumber + \", \" + this._maxNumber + \"]\";\n  };\n  return ValueRange;\n}();\nexports.YEAR_RANGE = new ValueRange(-999999999, 999999999);\nexports.MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);\nexports.DAY_OF_MONTH_RANGE = new ValueRange(1, 31);\nexports.HOUR_OF_DAY_RANGE = new ValueRange(0, 23);\nexports.MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);\nexports.SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);\nexports.NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);\nexports.MINUTES_PER_HOUR = 60;\nexports.SECONDS_PER_MINUTE = 60;\nexports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.NANOS_PER_SECOND = 1000000000;\nexports.NANOS_PER_MILLISECOND = 1000000;\nexports.NANOS_PER_MINUTE = exports.NANOS_PER_SECOND * exports.SECONDS_PER_MINUTE;\nexports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.DAYS_0000_TO_1970 = 719528;\nexports.DAYS_PER_400_YEAR_CYCLE = 146097;\nexports.SECONDS_PER_DAY = 86400;\nfunction normalizeSecondsForDuration(seconds, nanoseconds) {\n  return (0, integer_1.int)(seconds).add(floorDiv(nanoseconds, exports.NANOS_PER_SECOND));\n}\nexports.normalizeSecondsForDuration = normalizeSecondsForDuration;\nfunction normalizeNanosecondsForDuration(nanoseconds) {\n  return floorMod(nanoseconds, exports.NANOS_PER_SECOND);\n}\nexports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;\n/**\n * Converts given local time into a single integer representing this same time in nanoseconds of the day.\n * @param {Integer|number|string} hour the hour of the local time to convert.\n * @param {Integer|number|string} minute the minute of the local time to convert.\n * @param {Integer|number|string} second the second of the local time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.\n * @return {Integer} nanoseconds representing the given local time.\n */\nfunction localTimeToNanoOfDay(hour, minute, second, nanosecond) {\n  hour = (0, integer_1.int)(hour);\n  minute = (0, integer_1.int)(minute);\n  second = (0, integer_1.int)(second);\n  nanosecond = (0, integer_1.int)(nanosecond);\n  var totalNanos = hour.multiply(exports.NANOS_PER_HOUR);\n  totalNanos = totalNanos.add(minute.multiply(exports.NANOS_PER_MINUTE));\n  totalNanos = totalNanos.add(second.multiply(exports.NANOS_PER_SECOND));\n  return totalNanos.add(nanosecond);\n}\nexports.localTimeToNanoOfDay = localTimeToNanoOfDay;\n/**\n * Converts given local date time into a single integer representing this same time in epoch seconds UTC.\n * @param {Integer|number|string} year the year of the local date-time to convert.\n * @param {Integer|number|string} month the month of the local date-time to convert.\n * @param {Integer|number|string} day the day of the local date-time to convert.\n * @param {Integer|number|string} hour the hour of the local date-time to convert.\n * @param {Integer|number|string} minute the minute of the local date-time to convert.\n * @param {Integer|number|string} second the second of the local date-time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.\n * @return {Integer} epoch second in UTC representing the given local date time.\n */\nfunction localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {\n  var epochDay = dateToEpochDay(year, month, day);\n  var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);\n  return epochDay.multiply(exports.SECONDS_PER_DAY).add(localTimeSeconds);\n}\nexports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;\n/**\n * Converts given local date into a single integer representing it's epoch day.\n * @param {Integer|number|string} year the year of the local date to convert.\n * @param {Integer|number|string} month the month of the local date to convert.\n * @param {Integer|number|string} day the day of the local date to convert.\n * @return {Integer} epoch day representing the given date.\n */\nfunction dateToEpochDay(year, month, day) {\n  year = (0, integer_1.int)(year);\n  month = (0, integer_1.int)(month);\n  day = (0, integer_1.int)(day);\n  var epochDay = year.multiply(365);\n  if (year.greaterThanOrEqual(0)) {\n    epochDay = epochDay.add(year.add(3).div(4).subtract(year.add(99).div(100)).add(year.add(399).div(400)));\n  } else {\n    epochDay = epochDay.subtract(year.div(-4).subtract(year.div(-100)).add(year.div(-400)));\n  }\n  epochDay = epochDay.add(month.multiply(367).subtract(362).div(12));\n  epochDay = epochDay.add(day.subtract(1));\n  if (month.greaterThan(2)) {\n    epochDay = epochDay.subtract(1);\n    if (!isLeapYear(year)) {\n      epochDay = epochDay.subtract(1);\n    }\n  }\n  return epochDay.subtract(exports.DAYS_0000_TO_1970);\n}\nexports.dateToEpochDay = dateToEpochDay;\n/**\n * Format given duration to an ISO 8601 string.\n * @param {Integer|number|string} months the number of months.\n * @param {Integer|number|string} days the number of days.\n * @param {Integer|number|string} seconds the number of seconds.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds.\n * @return {string} ISO string that represents given duration.\n */\nfunction durationToIsoString(months, days, seconds, nanoseconds) {\n  var monthsString = formatNumber(months);\n  var daysString = formatNumber(days);\n  var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);\n  return \"P\" + monthsString + \"M\" + daysString + \"DT\" + secondsAndNanosecondsString + \"S\";\n}\nexports.durationToIsoString = durationToIsoString;\n/**\n * Formats given time to an ISO 8601 string.\n * @param {Integer|number|string} hour the hour value.\n * @param {Integer|number|string} minute the minute value.\n * @param {Integer|number|string} second the second value.\n * @param {Integer|number|string} nanosecond the nanosecond value.\n * @return {string} ISO string that represents given time.\n */\nfunction timeToIsoString(hour, minute, second, nanosecond) {\n  var hourString = formatNumber(hour, 2);\n  var minuteString = formatNumber(minute, 2);\n  var secondString = formatNumber(second, 2);\n  var nanosecondString = formatNanosecond(nanosecond);\n  return hourString + \":\" + minuteString + \":\" + secondString + nanosecondString;\n}\nexports.timeToIsoString = timeToIsoString;\n/**\n * Formats given time zone offset in seconds to string representation like '±HH:MM', '±HH:MM:SS' or 'Z' for UTC.\n * @param {Integer|number|string} offsetSeconds the offset in seconds.\n * @return {string} ISO string that represents given offset.\n */\nfunction timeZoneOffsetToIsoString(offsetSeconds) {\n  offsetSeconds = (0, integer_1.int)(offsetSeconds);\n  if (offsetSeconds.equals(0)) {\n    return 'Z';\n  }\n  var isNegative = offsetSeconds.isNegative();\n  if (isNegative) {\n    offsetSeconds = offsetSeconds.multiply(-1);\n  }\n  var signPrefix = isNegative ? '-' : '+';\n  var hours = formatNumber(offsetSeconds.div(exports.SECONDS_PER_HOUR), 2);\n  var minutes = formatNumber(offsetSeconds.div(exports.SECONDS_PER_MINUTE).modulo(exports.MINUTES_PER_HOUR), 2);\n  var secondsValue = offsetSeconds.modulo(exports.SECONDS_PER_MINUTE);\n  var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);\n  return seconds ? \"\" + signPrefix + hours + \":\" + minutes + \":\" + seconds : \"\" + signPrefix + hours + \":\" + minutes;\n}\nexports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;\n/**\n * Formats given date to an ISO 8601 string.\n * @param {Integer|number|string} year the date year.\n * @param {Integer|number|string} month the date month.\n * @param {Integer|number|string} day the date day.\n * @return {string} ISO string that represents given date.\n */\nfunction dateToIsoString(year, month, day) {\n  year = (0, integer_1.int)(year);\n  var isNegative = year.isNegative();\n  if (isNegative) {\n    year = year.multiply(-1);\n  }\n  var yearString = formatNumber(year, 4);\n  if (isNegative) {\n    yearString = '-' + yearString;\n  }\n  var monthString = formatNumber(month, 2);\n  var dayString = formatNumber(day, 2);\n  return yearString + \"-\" + monthString + \"-\" + dayString;\n}\nexports.dateToIsoString = dateToIsoString;\n/**\n * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.\n * @param {global.Date} standardDate the standard JavaScript date.\n * @param {Integer|number|bigint|undefined} nanoseconds the optional number of nanoseconds.\n * @return {Integer|number|bigint} the total amount of nanoseconds.\n */\nfunction totalNanoseconds(standardDate, nanoseconds) {\n  nanoseconds = nanoseconds || 0;\n  var nanosFromMillis = standardDate.getMilliseconds() * exports.NANOS_PER_MILLISECOND;\n  return add(nanoseconds, nanosFromMillis);\n}\nexports.totalNanoseconds = totalNanoseconds;\n/**\n * Get the time zone offset in seconds from the given standard JavaScript date.\n *\n * <b>Implementation note:</b>\n * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.\n * So positive value means offset is behind UTC and negative value means it is ahead.\n * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.\n * This is different from standard JavaScript dates and that's why implementation negates the returned value.\n *\n * @param {global.Date} standardDate the standard JavaScript date.\n * @return {number} the time zone offset in seconds.\n */\nfunction timeZoneOffsetInSeconds(standardDate) {\n  var offsetInMinutes = standardDate.getTimezoneOffset();\n  if (offsetInMinutes === 0) {\n    return 0;\n  }\n  return -1 * offsetInMinutes * exports.SECONDS_PER_MINUTE;\n}\nexports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;\n/**\n * Assert that the year value is valid.\n * @param {Integer|number} year the value to check.\n * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidYear(year) {\n  return assertValidTemporalValue(year, exports.YEAR_RANGE, 'Year');\n}\nexports.assertValidYear = assertValidYear;\n/**\n * Assert that the month value is valid.\n * @param {Integer|number} month the value to check.\n * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidMonth(month) {\n  return assertValidTemporalValue(month, exports.MONTH_OF_YEAR_RANGE, 'Month');\n}\nexports.assertValidMonth = assertValidMonth;\n/**\n * Assert that the day value is valid.\n * @param {Integer|number} day the value to check.\n * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidDay(day) {\n  return assertValidTemporalValue(day, exports.DAY_OF_MONTH_RANGE, 'Day');\n}\nexports.assertValidDay = assertValidDay;\n/**\n * Assert that the hour value is valid.\n * @param {Integer|number} hour the value to check.\n * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidHour(hour) {\n  return assertValidTemporalValue(hour, exports.HOUR_OF_DAY_RANGE, 'Hour');\n}\nexports.assertValidHour = assertValidHour;\n/**\n * Assert that the minute value is valid.\n * @param {Integer|number} minute the value to check.\n * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidMinute(minute) {\n  return assertValidTemporalValue(minute, exports.MINUTE_OF_HOUR_RANGE, 'Minute');\n}\nexports.assertValidMinute = assertValidMinute;\n/**\n * Assert that the second value is valid.\n * @param {Integer|number} second the value to check.\n * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidSecond(second) {\n  return assertValidTemporalValue(second, exports.SECOND_OF_MINUTE_RANGE, 'Second');\n}\nexports.assertValidSecond = assertValidSecond;\n/**\n * Assert that the nanosecond value is valid.\n * @param {Integer|number} nanosecond the value to check.\n * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidNanosecond(nanosecond) {\n  return assertValidTemporalValue(nanosecond, exports.NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');\n}\nexports.assertValidNanosecond = assertValidNanosecond;\n/**\n * Check if the given value is of expected type and is in the expected range.\n * @param {Integer|number} value the value to check.\n * @param {ValueRange} range the range.\n * @param {string} name the name of the value.\n * @return {Integer|number} the value if valid. Exception is thrown otherwise.\n */\nfunction assertValidTemporalValue(value, range, name) {\n  (0, util_1.assertNumberOrInteger)(value, name);\n  if (!range.contains(value)) {\n    throw (0, error_1.newError)(name + \" is expected to be in range \" + range + \" but was: \" + value);\n  }\n  return value;\n}\n/**\n * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.\n * @param {Integer|number|string} hour the hour of the local time.\n * @param {Integer|number|string} minute the minute of the local time.\n * @param {Integer|number|string} second the second of the local time.\n * @return {Integer} seconds representing the given local time.\n */\nfunction localTimeToSecondOfDay(hour, minute, second) {\n  hour = (0, integer_1.int)(hour);\n  minute = (0, integer_1.int)(minute);\n  second = (0, integer_1.int)(second);\n  var totalSeconds = hour.multiply(exports.SECONDS_PER_HOUR);\n  totalSeconds = totalSeconds.add(minute.multiply(exports.SECONDS_PER_MINUTE));\n  return totalSeconds.add(second);\n}\n/**\n * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.\n * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.\n * @return {boolean} `true` if given year is a leap year, `false` otherwise.\n */\nfunction isLeapYear(year) {\n  year = (0, integer_1.int)(year);\n  if (!year.modulo(4).equals(0)) {\n    return false;\n  } else if (!year.modulo(100).equals(0)) {\n    return true;\n  } else if (!year.modulo(400).equals(0)) {\n    return false;\n  } else {\n    return true;\n  }\n}\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\nfunction floorDiv(x, y) {\n  x = (0, integer_1.int)(x);\n  y = (0, integer_1.int)(y);\n  var result = x.div(y);\n  if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {\n    result = result.subtract(1);\n  }\n  return result;\n}\nexports.floorDiv = floorDiv;\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\nfunction floorMod(x, y) {\n  x = (0, integer_1.int)(x);\n  y = (0, integer_1.int)(y);\n  return x.subtract(floorDiv(x, y).multiply(y));\n}\nexports.floorMod = floorMod;\n/**\n * @param {Integer|number|string} seconds the number of seconds to format.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.\n * @return {string} formatted value.\n */\nfunction formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {\n  seconds = (0, integer_1.int)(seconds);\n  nanoseconds = (0, integer_1.int)(nanoseconds);\n  var secondsString;\n  var nanosecondsString;\n  var secondsNegative = seconds.isNegative();\n  var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);\n  if (secondsNegative && nanosecondsGreaterThanZero) {\n    if (seconds.equals(-1)) {\n      secondsString = '-0';\n    } else {\n      secondsString = seconds.add(1).toString();\n    }\n  } else {\n    secondsString = seconds.toString();\n  }\n  if (nanosecondsGreaterThanZero) {\n    if (secondsNegative) {\n      nanosecondsString = formatNanosecond(nanoseconds.negate().add(2 * exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n    } else {\n      nanosecondsString = formatNanosecond(nanoseconds.add(exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n    }\n  }\n  return nanosecondsString ? secondsString + nanosecondsString : secondsString;\n}\n/**\n * @param {Integer|number|string} value the number of nanoseconds to format.\n * @return {string} formatted and possibly left-padded nanoseconds part as string.\n */\nfunction formatNanosecond(value) {\n  value = (0, integer_1.int)(value);\n  return value.equals(0) ? '' : '.' + formatNumber(value, 9);\n}\n/**\n * @param {Integer|number|string} num the number to format.\n * @param {number} [stringLength=undefined] the string length to left-pad to.\n * @return {string} formatted and possibly left-padded number as string.\n */\nfunction formatNumber(num, stringLength) {\n  num = (0, integer_1.int)(num);\n  var isNegative = num.isNegative();\n  if (isNegative) {\n    num = num.negate();\n  }\n  var numString = num.toString();\n  if (stringLength) {\n    // left pad the string with zeroes\n    while (numString.length < stringLength) {\n      numString = '0' + numString;\n    }\n  }\n  return isNegative ? '-' + numString : numString;\n}\nfunction add(x, y) {\n  if (x instanceof integer_1.default) {\n    return x.add(y);\n  } else if (typeof x === 'bigint') {\n    return x + BigInt(y);\n  }\n  return x + y;\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","floorMod","floorDiv","assertValidNanosecond","assertValidSecond","assertValidMinute","assertValidHour","assertValidDay","assertValidMonth","assertValidYear","timeZoneOffsetInSeconds","totalNanoseconds","dateToIsoString","timeZoneOffsetToIsoString","timeToIsoString","durationToIsoString","dateToEpochDay","localDateTimeToEpochSecond","localTimeToNanoOfDay","normalizeNanosecondsForDuration","normalizeSecondsForDuration","SECONDS_PER_DAY","DAYS_PER_400_YEAR_CYCLE","DAYS_0000_TO_1970","NANOS_PER_HOUR","NANOS_PER_MINUTE","NANOS_PER_MILLISECOND","NANOS_PER_SECOND","SECONDS_PER_HOUR","SECONDS_PER_MINUTE","MINUTES_PER_HOUR","NANOSECOND_OF_SECOND_RANGE","SECOND_OF_MINUTE_RANGE","MINUTE_OF_HOUR_RANGE","HOUR_OF_DAY_RANGE","DAY_OF_MONTH_RANGE","MONTH_OF_YEAR_RANGE","YEAR_RANGE","integer_1","require","error_1","util_1","ValueRange","min","max","_minNumber","_maxNumber","_minInteger","int","_maxInteger","contains","isInt","default","greaterThanOrEqual","lessThanOrEqual","intValue","toString","seconds","nanoseconds","add","hour","minute","second","nanosecond","totalNanos","multiply","year","month","day","epochDay","localTimeSeconds","localTimeToSecondOfDay","div","subtract","greaterThan","isLeapYear","months","days","monthsString","formatNumber","daysString","secondsAndNanosecondsString","formatSecondsAndNanosecondsForDuration","hourString","minuteString","secondString","nanosecondString","formatNanosecond","offsetSeconds","equals","isNegative","signPrefix","hours","minutes","modulo","secondsValue","yearString","monthString","dayString","standardDate","nanosFromMillis","getMilliseconds","offsetInMinutes","getTimezoneOffset","assertValidTemporalValue","range","name","assertNumberOrInteger","newError","totalSeconds","x","y","isPositive","notEquals","secondsString","nanosecondsString","secondsNegative","nanosecondsGreaterThanZero","negate","num","stringLength","numString","length","BigInt"],"sources":["C:/Stanford/DigitalTracesApp3/node_modules/neo4j-driver-core/lib/internal/temporal-util.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.floorMod = exports.floorDiv = exports.assertValidNanosecond = exports.assertValidSecond = exports.assertValidMinute = exports.assertValidHour = exports.assertValidDay = exports.assertValidMonth = exports.assertValidYear = exports.timeZoneOffsetInSeconds = exports.totalNanoseconds = exports.dateToIsoString = exports.timeZoneOffsetToIsoString = exports.timeToIsoString = exports.durationToIsoString = exports.dateToEpochDay = exports.localDateTimeToEpochSecond = exports.localTimeToNanoOfDay = exports.normalizeNanosecondsForDuration = exports.normalizeSecondsForDuration = exports.SECONDS_PER_DAY = exports.DAYS_PER_400_YEAR_CYCLE = exports.DAYS_0000_TO_1970 = exports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE = exports.NANOS_PER_MILLISECOND = exports.NANOS_PER_SECOND = exports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE = exports.MINUTES_PER_HOUR = exports.NANOSECOND_OF_SECOND_RANGE = exports.SECOND_OF_MINUTE_RANGE = exports.MINUTE_OF_HOUR_RANGE = exports.HOUR_OF_DAY_RANGE = exports.DAY_OF_MONTH_RANGE = exports.MONTH_OF_YEAR_RANGE = exports.YEAR_RANGE = void 0;\nvar integer_1 = __importStar(require(\"../integer\"));\nvar error_1 = require(\"../error\");\nvar util_1 = require(\"./util\");\n/*\n  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.\n\n  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived\n  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere\n  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.\n\n  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the\n  conversion functions.\n */\nvar ValueRange = /** @class */ (function () {\n    function ValueRange(min, max) {\n        this._minNumber = min;\n        this._maxNumber = max;\n        this._minInteger = (0, integer_1.int)(min);\n        this._maxInteger = (0, integer_1.int)(max);\n    }\n    ValueRange.prototype.contains = function (value) {\n        if ((0, integer_1.isInt)(value) && value instanceof integer_1.default) {\n            return (value.greaterThanOrEqual(this._minInteger) &&\n                value.lessThanOrEqual(this._maxInteger));\n        }\n        else if (typeof value === 'bigint') {\n            var intValue = (0, integer_1.int)(value);\n            return (intValue.greaterThanOrEqual(this._minInteger) &&\n                intValue.lessThanOrEqual(this._maxInteger));\n        }\n        else {\n            return value >= this._minNumber && value <= this._maxNumber;\n        }\n    };\n    ValueRange.prototype.toString = function () {\n        return \"[\" + this._minNumber + \", \" + this._maxNumber + \"]\";\n    };\n    return ValueRange;\n}());\nexports.YEAR_RANGE = new ValueRange(-999999999, 999999999);\nexports.MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);\nexports.DAY_OF_MONTH_RANGE = new ValueRange(1, 31);\nexports.HOUR_OF_DAY_RANGE = new ValueRange(0, 23);\nexports.MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);\nexports.SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);\nexports.NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);\nexports.MINUTES_PER_HOUR = 60;\nexports.SECONDS_PER_MINUTE = 60;\nexports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.NANOS_PER_SECOND = 1000000000;\nexports.NANOS_PER_MILLISECOND = 1000000;\nexports.NANOS_PER_MINUTE = exports.NANOS_PER_SECOND * exports.SECONDS_PER_MINUTE;\nexports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.DAYS_0000_TO_1970 = 719528;\nexports.DAYS_PER_400_YEAR_CYCLE = 146097;\nexports.SECONDS_PER_DAY = 86400;\nfunction normalizeSecondsForDuration(seconds, nanoseconds) {\n    return (0, integer_1.int)(seconds).add(floorDiv(nanoseconds, exports.NANOS_PER_SECOND));\n}\nexports.normalizeSecondsForDuration = normalizeSecondsForDuration;\nfunction normalizeNanosecondsForDuration(nanoseconds) {\n    return floorMod(nanoseconds, exports.NANOS_PER_SECOND);\n}\nexports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;\n/**\n * Converts given local time into a single integer representing this same time in nanoseconds of the day.\n * @param {Integer|number|string} hour the hour of the local time to convert.\n * @param {Integer|number|string} minute the minute of the local time to convert.\n * @param {Integer|number|string} second the second of the local time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.\n * @return {Integer} nanoseconds representing the given local time.\n */\nfunction localTimeToNanoOfDay(hour, minute, second, nanosecond) {\n    hour = (0, integer_1.int)(hour);\n    minute = (0, integer_1.int)(minute);\n    second = (0, integer_1.int)(second);\n    nanosecond = (0, integer_1.int)(nanosecond);\n    var totalNanos = hour.multiply(exports.NANOS_PER_HOUR);\n    totalNanos = totalNanos.add(minute.multiply(exports.NANOS_PER_MINUTE));\n    totalNanos = totalNanos.add(second.multiply(exports.NANOS_PER_SECOND));\n    return totalNanos.add(nanosecond);\n}\nexports.localTimeToNanoOfDay = localTimeToNanoOfDay;\n/**\n * Converts given local date time into a single integer representing this same time in epoch seconds UTC.\n * @param {Integer|number|string} year the year of the local date-time to convert.\n * @param {Integer|number|string} month the month of the local date-time to convert.\n * @param {Integer|number|string} day the day of the local date-time to convert.\n * @param {Integer|number|string} hour the hour of the local date-time to convert.\n * @param {Integer|number|string} minute the minute of the local date-time to convert.\n * @param {Integer|number|string} second the second of the local date-time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.\n * @return {Integer} epoch second in UTC representing the given local date time.\n */\nfunction localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {\n    var epochDay = dateToEpochDay(year, month, day);\n    var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);\n    return epochDay.multiply(exports.SECONDS_PER_DAY).add(localTimeSeconds);\n}\nexports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;\n/**\n * Converts given local date into a single integer representing it's epoch day.\n * @param {Integer|number|string} year the year of the local date to convert.\n * @param {Integer|number|string} month the month of the local date to convert.\n * @param {Integer|number|string} day the day of the local date to convert.\n * @return {Integer} epoch day representing the given date.\n */\nfunction dateToEpochDay(year, month, day) {\n    year = (0, integer_1.int)(year);\n    month = (0, integer_1.int)(month);\n    day = (0, integer_1.int)(day);\n    var epochDay = year.multiply(365);\n    if (year.greaterThanOrEqual(0)) {\n        epochDay = epochDay.add(year\n            .add(3)\n            .div(4)\n            .subtract(year.add(99).div(100))\n            .add(year.add(399).div(400)));\n    }\n    else {\n        epochDay = epochDay.subtract(year\n            .div(-4)\n            .subtract(year.div(-100))\n            .add(year.div(-400)));\n    }\n    epochDay = epochDay.add(month\n        .multiply(367)\n        .subtract(362)\n        .div(12));\n    epochDay = epochDay.add(day.subtract(1));\n    if (month.greaterThan(2)) {\n        epochDay = epochDay.subtract(1);\n        if (!isLeapYear(year)) {\n            epochDay = epochDay.subtract(1);\n        }\n    }\n    return epochDay.subtract(exports.DAYS_0000_TO_1970);\n}\nexports.dateToEpochDay = dateToEpochDay;\n/**\n * Format given duration to an ISO 8601 string.\n * @param {Integer|number|string} months the number of months.\n * @param {Integer|number|string} days the number of days.\n * @param {Integer|number|string} seconds the number of seconds.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds.\n * @return {string} ISO string that represents given duration.\n */\nfunction durationToIsoString(months, days, seconds, nanoseconds) {\n    var monthsString = formatNumber(months);\n    var daysString = formatNumber(days);\n    var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);\n    return \"P\" + monthsString + \"M\" + daysString + \"DT\" + secondsAndNanosecondsString + \"S\";\n}\nexports.durationToIsoString = durationToIsoString;\n/**\n * Formats given time to an ISO 8601 string.\n * @param {Integer|number|string} hour the hour value.\n * @param {Integer|number|string} minute the minute value.\n * @param {Integer|number|string} second the second value.\n * @param {Integer|number|string} nanosecond the nanosecond value.\n * @return {string} ISO string that represents given time.\n */\nfunction timeToIsoString(hour, minute, second, nanosecond) {\n    var hourString = formatNumber(hour, 2);\n    var minuteString = formatNumber(minute, 2);\n    var secondString = formatNumber(second, 2);\n    var nanosecondString = formatNanosecond(nanosecond);\n    return hourString + \":\" + minuteString + \":\" + secondString + nanosecondString;\n}\nexports.timeToIsoString = timeToIsoString;\n/**\n * Formats given time zone offset in seconds to string representation like '±HH:MM', '±HH:MM:SS' or 'Z' for UTC.\n * @param {Integer|number|string} offsetSeconds the offset in seconds.\n * @return {string} ISO string that represents given offset.\n */\nfunction timeZoneOffsetToIsoString(offsetSeconds) {\n    offsetSeconds = (0, integer_1.int)(offsetSeconds);\n    if (offsetSeconds.equals(0)) {\n        return 'Z';\n    }\n    var isNegative = offsetSeconds.isNegative();\n    if (isNegative) {\n        offsetSeconds = offsetSeconds.multiply(-1);\n    }\n    var signPrefix = isNegative ? '-' : '+';\n    var hours = formatNumber(offsetSeconds.div(exports.SECONDS_PER_HOUR), 2);\n    var minutes = formatNumber(offsetSeconds.div(exports.SECONDS_PER_MINUTE).modulo(exports.MINUTES_PER_HOUR), 2);\n    var secondsValue = offsetSeconds.modulo(exports.SECONDS_PER_MINUTE);\n    var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);\n    return seconds\n        ? \"\" + signPrefix + hours + \":\" + minutes + \":\" + seconds\n        : \"\" + signPrefix + hours + \":\" + minutes;\n}\nexports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;\n/**\n * Formats given date to an ISO 8601 string.\n * @param {Integer|number|string} year the date year.\n * @param {Integer|number|string} month the date month.\n * @param {Integer|number|string} day the date day.\n * @return {string} ISO string that represents given date.\n */\nfunction dateToIsoString(year, month, day) {\n    year = (0, integer_1.int)(year);\n    var isNegative = year.isNegative();\n    if (isNegative) {\n        year = year.multiply(-1);\n    }\n    var yearString = formatNumber(year, 4);\n    if (isNegative) {\n        yearString = '-' + yearString;\n    }\n    var monthString = formatNumber(month, 2);\n    var dayString = formatNumber(day, 2);\n    return yearString + \"-\" + monthString + \"-\" + dayString;\n}\nexports.dateToIsoString = dateToIsoString;\n/**\n * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.\n * @param {global.Date} standardDate the standard JavaScript date.\n * @param {Integer|number|bigint|undefined} nanoseconds the optional number of nanoseconds.\n * @return {Integer|number|bigint} the total amount of nanoseconds.\n */\nfunction totalNanoseconds(standardDate, nanoseconds) {\n    nanoseconds = nanoseconds || 0;\n    var nanosFromMillis = standardDate.getMilliseconds() * exports.NANOS_PER_MILLISECOND;\n    return add(nanoseconds, nanosFromMillis);\n}\nexports.totalNanoseconds = totalNanoseconds;\n/**\n * Get the time zone offset in seconds from the given standard JavaScript date.\n *\n * <b>Implementation note:</b>\n * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.\n * So positive value means offset is behind UTC and negative value means it is ahead.\n * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.\n * This is different from standard JavaScript dates and that's why implementation negates the returned value.\n *\n * @param {global.Date} standardDate the standard JavaScript date.\n * @return {number} the time zone offset in seconds.\n */\nfunction timeZoneOffsetInSeconds(standardDate) {\n    var offsetInMinutes = standardDate.getTimezoneOffset();\n    if (offsetInMinutes === 0) {\n        return 0;\n    }\n    return -1 * offsetInMinutes * exports.SECONDS_PER_MINUTE;\n}\nexports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;\n/**\n * Assert that the year value is valid.\n * @param {Integer|number} year the value to check.\n * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidYear(year) {\n    return assertValidTemporalValue(year, exports.YEAR_RANGE, 'Year');\n}\nexports.assertValidYear = assertValidYear;\n/**\n * Assert that the month value is valid.\n * @param {Integer|number} month the value to check.\n * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidMonth(month) {\n    return assertValidTemporalValue(month, exports.MONTH_OF_YEAR_RANGE, 'Month');\n}\nexports.assertValidMonth = assertValidMonth;\n/**\n * Assert that the day value is valid.\n * @param {Integer|number} day the value to check.\n * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidDay(day) {\n    return assertValidTemporalValue(day, exports.DAY_OF_MONTH_RANGE, 'Day');\n}\nexports.assertValidDay = assertValidDay;\n/**\n * Assert that the hour value is valid.\n * @param {Integer|number} hour the value to check.\n * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidHour(hour) {\n    return assertValidTemporalValue(hour, exports.HOUR_OF_DAY_RANGE, 'Hour');\n}\nexports.assertValidHour = assertValidHour;\n/**\n * Assert that the minute value is valid.\n * @param {Integer|number} minute the value to check.\n * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidMinute(minute) {\n    return assertValidTemporalValue(minute, exports.MINUTE_OF_HOUR_RANGE, 'Minute');\n}\nexports.assertValidMinute = assertValidMinute;\n/**\n * Assert that the second value is valid.\n * @param {Integer|number} second the value to check.\n * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidSecond(second) {\n    return assertValidTemporalValue(second, exports.SECOND_OF_MINUTE_RANGE, 'Second');\n}\nexports.assertValidSecond = assertValidSecond;\n/**\n * Assert that the nanosecond value is valid.\n * @param {Integer|number} nanosecond the value to check.\n * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidNanosecond(nanosecond) {\n    return assertValidTemporalValue(nanosecond, exports.NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');\n}\nexports.assertValidNanosecond = assertValidNanosecond;\n/**\n * Check if the given value is of expected type and is in the expected range.\n * @param {Integer|number} value the value to check.\n * @param {ValueRange} range the range.\n * @param {string} name the name of the value.\n * @return {Integer|number} the value if valid. Exception is thrown otherwise.\n */\nfunction assertValidTemporalValue(value, range, name) {\n    (0, util_1.assertNumberOrInteger)(value, name);\n    if (!range.contains(value)) {\n        throw (0, error_1.newError)(name + \" is expected to be in range \" + range + \" but was: \" + value);\n    }\n    return value;\n}\n/**\n * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.\n * @param {Integer|number|string} hour the hour of the local time.\n * @param {Integer|number|string} minute the minute of the local time.\n * @param {Integer|number|string} second the second of the local time.\n * @return {Integer} seconds representing the given local time.\n */\nfunction localTimeToSecondOfDay(hour, minute, second) {\n    hour = (0, integer_1.int)(hour);\n    minute = (0, integer_1.int)(minute);\n    second = (0, integer_1.int)(second);\n    var totalSeconds = hour.multiply(exports.SECONDS_PER_HOUR);\n    totalSeconds = totalSeconds.add(minute.multiply(exports.SECONDS_PER_MINUTE));\n    return totalSeconds.add(second);\n}\n/**\n * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.\n * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.\n * @return {boolean} `true` if given year is a leap year, `false` otherwise.\n */\nfunction isLeapYear(year) {\n    year = (0, integer_1.int)(year);\n    if (!year.modulo(4).equals(0)) {\n        return false;\n    }\n    else if (!year.modulo(100).equals(0)) {\n        return true;\n    }\n    else if (!year.modulo(400).equals(0)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\nfunction floorDiv(x, y) {\n    x = (0, integer_1.int)(x);\n    y = (0, integer_1.int)(y);\n    var result = x.div(y);\n    if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {\n        result = result.subtract(1);\n    }\n    return result;\n}\nexports.floorDiv = floorDiv;\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\nfunction floorMod(x, y) {\n    x = (0, integer_1.int)(x);\n    y = (0, integer_1.int)(y);\n    return x.subtract(floorDiv(x, y).multiply(y));\n}\nexports.floorMod = floorMod;\n/**\n * @param {Integer|number|string} seconds the number of seconds to format.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.\n * @return {string} formatted value.\n */\nfunction formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {\n    seconds = (0, integer_1.int)(seconds);\n    nanoseconds = (0, integer_1.int)(nanoseconds);\n    var secondsString;\n    var nanosecondsString;\n    var secondsNegative = seconds.isNegative();\n    var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);\n    if (secondsNegative && nanosecondsGreaterThanZero) {\n        if (seconds.equals(-1)) {\n            secondsString = '-0';\n        }\n        else {\n            secondsString = seconds.add(1).toString();\n        }\n    }\n    else {\n        secondsString = seconds.toString();\n    }\n    if (nanosecondsGreaterThanZero) {\n        if (secondsNegative) {\n            nanosecondsString = formatNanosecond(nanoseconds\n                .negate()\n                .add(2 * exports.NANOS_PER_SECOND)\n                .modulo(exports.NANOS_PER_SECOND));\n        }\n        else {\n            nanosecondsString = formatNanosecond(nanoseconds.add(exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n        }\n    }\n    return nanosecondsString ? secondsString + nanosecondsString : secondsString;\n}\n/**\n * @param {Integer|number|string} value the number of nanoseconds to format.\n * @return {string} formatted and possibly left-padded nanoseconds part as string.\n */\nfunction formatNanosecond(value) {\n    value = (0, integer_1.int)(value);\n    return value.equals(0) ? '' : '.' + formatNumber(value, 9);\n}\n/**\n * @param {Integer|number|string} num the number to format.\n * @param {number} [stringLength=undefined] the string length to left-pad to.\n * @return {string} formatted and possibly left-padded number as string.\n */\nfunction formatNumber(num, stringLength) {\n    num = (0, integer_1.int)(num);\n    var isNegative = num.isNegative();\n    if (isNegative) {\n        num = num.negate();\n    }\n    var numString = num.toString();\n    if (stringLength) {\n        // left pad the string with zeroes\n        while (numString.length < stringLength) {\n            numString = '0' + numString;\n        }\n    }\n    return isNegative ? '-' + numString : numString;\n}\nfunction add(x, y) {\n    if (x instanceof integer_1.default) {\n        return x.add(y);\n    }\n    else if (typeof x === 'bigint') {\n        return x + BigInt(y);\n    }\n    return x + y;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}