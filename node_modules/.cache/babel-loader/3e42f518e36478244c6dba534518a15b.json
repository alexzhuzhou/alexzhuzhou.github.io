{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar channel_1 = require(\"../channel\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\nvar Structure = /** @class */function () {\n  /**\n   * Create new instance\n   */\n  function Structure(signature, fields) {\n    this.signature = signature;\n    this.fields = fields;\n  }\n  Structure.prototype.toString = function () {\n    var fieldStr = '';\n    for (var i = 0; i < this.fields.length; i++) {\n      if (i > 0) {\n        fieldStr += ', ';\n      }\n      fieldStr += this.fields[i];\n    }\n    return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n  };\n  return Structure;\n}();\nexports.Structure = Structure;\n/**\n * Class to pack\n * @access private\n */\nvar Packer = /** @class */function () {\n  /**\n   * @constructor\n   * @param {Chunker} channel the chunker backed by a network channel.\n   */\n  function Packer(channel) {\n    this._ch = channel;\n    this._byteArraysSupported = true;\n  }\n  /**\n   * Creates a packable function out of the provided value\n   * @param x the value to pack\n   * @returns Function\n   */\n  Packer.prototype.packable = function (x) {\n    var _this = this;\n    if (x === null) {\n      return function () {\n        return _this._ch.writeUInt8(NULL);\n      };\n    } else if (x === true) {\n      return function () {\n        return _this._ch.writeUInt8(TRUE);\n      };\n    } else if (x === false) {\n      return function () {\n        return _this._ch.writeUInt8(FALSE);\n      };\n    } else if (typeof x === 'number') {\n      return function () {\n        return _this.packFloat(x);\n      };\n    } else if (typeof x === 'string') {\n      return function () {\n        return _this.packString(x);\n      };\n    } else if (typeof x === 'bigint') {\n      return function () {\n        return _this.packInteger((0, neo4j_driver_core_1.int)(x));\n      };\n    } else if ((0, neo4j_driver_core_1.isInt)(x)) {\n      return function () {\n        return _this.packInteger(x);\n      };\n    } else if (x instanceof Int8Array) {\n      return function () {\n        return _this.packBytes(x);\n      };\n    } else if (x instanceof Array) {\n      return function () {\n        _this.packListHeader(x.length);\n        for (var i_1 = 0; i_1 < x.length; i_1++) {\n          _this.packable(x[i_1] === undefined ? null : x[i_1])();\n        }\n      };\n    } else if (isIterable(x)) {\n      return this.packableIterable(x);\n    } else if (x instanceof neo4j_driver_core_1.Node) {\n      return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \" + x);\n    } else if (x instanceof neo4j_driver_core_1.Relationship) {\n      return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \" + x);\n    } else if (x instanceof neo4j_driver_core_1.Path) {\n      return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \" + x);\n    } else if (x instanceof Structure) {\n      var packableFields = [];\n      for (var i = 0; i < x.fields.length; i++) {\n        packableFields[i] = this.packable(x.fields[i]);\n      }\n      return function () {\n        return _this.packStruct(x.signature, packableFields);\n      };\n    } else if (typeof x === 'object') {\n      return function () {\n        var keys = Object.keys(x);\n        var count = 0;\n        for (var i_2 = 0; i_2 < keys.length; i_2++) {\n          if (x[keys[i_2]] !== undefined) {\n            count++;\n          }\n        }\n        _this.packMapHeader(count);\n        for (var i_3 = 0; i_3 < keys.length; i_3++) {\n          var key = keys[i_3];\n          if (x[key] !== undefined) {\n            _this.packString(key);\n            _this.packable(x[key])();\n          }\n        }\n      };\n    } else {\n      return this._nonPackableValue(\"Unable to pack the given value: \" + x);\n    }\n  };\n  Packer.prototype.packableIterable = function (iterable) {\n    try {\n      var array = Array.from(iterable);\n      return this.packable(array);\n    } catch (e) {\n      // handle errors from iterable to array conversion\n      throw (0, neo4j_driver_core_1.newError)(\"Cannot pack given iterable, \" + e.message + \": \" + iterable);\n    }\n  };\n  /**\n   * Packs a struct\n   * @param signature the signature of the struct\n   * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n   */\n  Packer.prototype.packStruct = function (signature, packableFields) {\n    packableFields = packableFields || [];\n    this.packStructHeader(packableFields.length, signature);\n    for (var i = 0; i < packableFields.length; i++) {\n      packableFields[i]();\n    }\n  };\n  Packer.prototype.packInteger = function (x) {\n    var high = x.high;\n    var low = x.low;\n    if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n      this._ch.writeInt8(low);\n    } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n      this._ch.writeUInt8(INT_8);\n      this._ch.writeInt8(low);\n    } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n      this._ch.writeUInt8(INT_16);\n      this._ch.writeInt16(low);\n    } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n      this._ch.writeUInt8(INT_32);\n      this._ch.writeInt32(low);\n    } else {\n      this._ch.writeUInt8(INT_64);\n      this._ch.writeInt32(high);\n      this._ch.writeInt32(low);\n    }\n  };\n  Packer.prototype.packFloat = function (x) {\n    this._ch.writeUInt8(FLOAT_64);\n    this._ch.writeFloat64(x);\n  };\n  Packer.prototype.packString = function (x) {\n    var bytes = channel_1.utf8.encode(x);\n    var size = bytes.length;\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_STRING | size);\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(STRING_8);\n      this._ch.writeUInt8(size);\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(STRING_16);\n      this._ch.writeUInt8(size / 256 >> 0);\n      this._ch.writeUInt8(size % 256);\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(STRING_32);\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n      this._ch.writeBytes(bytes);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('UTF-8 strings of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.packListHeader = function (size) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_LIST | size);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(LIST_8);\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(LIST_16);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(LIST_32);\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Lists of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.packBytes = function (array) {\n    if (this._byteArraysSupported) {\n      this.packBytesHeader(array.length);\n      for (var i = 0; i < array.length; i++) {\n        this._ch.writeInt8(array[i]);\n      }\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Byte arrays are not supported by the database this driver is connected to');\n    }\n  };\n  Packer.prototype.packBytesHeader = function (size) {\n    if (size < 0x100) {\n      this._ch.writeUInt8(BYTES_8);\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(BYTES_16);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(BYTES_32);\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Byte arrays of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.packMapHeader = function (size) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_MAP | size);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(MAP_8);\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(MAP_16);\n      this._ch.writeUInt8(size / 256 >> 0);\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(MAP_32);\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Maps of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.packStructHeader = function (size, signature) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_STRUCT | size);\n      this._ch.writeUInt8(signature);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(STRUCT_8);\n      this._ch.writeUInt8(size);\n      this._ch.writeUInt8(signature);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(STRUCT_16);\n      this._ch.writeUInt8(size / 256 >> 0);\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Structures of size ' + size + ' are not supported');\n    }\n  };\n  Packer.prototype.disableByteArrays = function () {\n    this._byteArraysSupported = false;\n  };\n  Packer.prototype._nonPackableValue = function (message) {\n    return function () {\n      throw (0, neo4j_driver_core_1.newError)(message, PROTOCOL_ERROR);\n    };\n  };\n  return Packer;\n}();\nexports.Packer = Packer;\n/**\n * Class to unpack\n * @access private\n */\nvar Unpacker = /** @class */function () {\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n   */\n  function Unpacker(disableLosslessIntegers, useBigInt) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n    if (useBigInt === void 0) {\n      useBigInt = false;\n    }\n    this._disableLosslessIntegers = disableLosslessIntegers;\n    this._useBigInt = useBigInt;\n  }\n  Unpacker.prototype.unpack = function (buffer) {\n    var marker = buffer.readUInt8();\n    var markerHigh = marker & 0xf0;\n    var markerLow = marker & 0x0f;\n    if (marker === NULL) {\n      return null;\n    }\n    var boolean = this._unpackBoolean(marker);\n    if (boolean !== null) {\n      return boolean;\n    }\n    var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n    if (numberOrInteger !== null) {\n      if ((0, neo4j_driver_core_1.isInt)(numberOrInteger)) {\n        if (this._useBigInt) {\n          return numberOrInteger.toBigInt();\n        } else if (this._disableLosslessIntegers) {\n          return numberOrInteger.toNumberOrInfinity();\n        }\n      }\n      return numberOrInteger;\n    }\n    var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n    if (string !== null) {\n      return string;\n    }\n    var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n    if (list !== null) {\n      return list;\n    }\n    var byteArray = this._unpackByteArray(marker, buffer);\n    if (byteArray !== null) {\n      return byteArray;\n    }\n    var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n    if (map !== null) {\n      return map;\n    }\n    var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n    if (struct !== null) {\n      return struct;\n    }\n    throw (0, neo4j_driver_core_1.newError)('Unknown packed value with marker ' + marker.toString(16));\n  };\n  Unpacker.prototype.unpackInteger = function (buffer) {\n    var marker = buffer.readUInt8();\n    var result = this._unpackInteger(marker, buffer);\n    if (result == null) {\n      throw (0, neo4j_driver_core_1.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n    }\n    return result;\n  };\n  Unpacker.prototype._unpackBoolean = function (marker) {\n    if (marker === TRUE) {\n      return true;\n    } else if (marker === FALSE) {\n      return false;\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackNumberOrInteger = function (marker, buffer) {\n    if (marker === FLOAT_64) {\n      return buffer.readFloat64();\n    } else {\n      return this._unpackInteger(marker, buffer);\n    }\n  };\n  Unpacker.prototype._unpackInteger = function (marker, buffer) {\n    if (marker >= 0 && marker < 128) {\n      return (0, neo4j_driver_core_1.int)(marker);\n    } else if (marker >= 240 && marker < 256) {\n      return (0, neo4j_driver_core_1.int)(marker - 256);\n    } else if (marker === INT_8) {\n      return (0, neo4j_driver_core_1.int)(buffer.readInt8());\n    } else if (marker === INT_16) {\n      return (0, neo4j_driver_core_1.int)(buffer.readInt16());\n    } else if (marker === INT_32) {\n      var b = buffer.readInt32();\n      return (0, neo4j_driver_core_1.int)(b);\n    } else if (marker === INT_64) {\n      var high = buffer.readInt32();\n      var low = buffer.readInt32();\n      return new neo4j_driver_core_1.Integer(low, high);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackString = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_STRING) {\n      return channel_1.utf8.decode(buffer, markerLow);\n    } else if (marker === STRING_8) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt8());\n    } else if (marker === STRING_16) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt16());\n    } else if (marker === STRING_32) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt32());\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackList = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_LIST) {\n      return this._unpackListWithSize(markerLow, buffer);\n    } else if (marker === LIST_8) {\n      return this._unpackListWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === LIST_16) {\n      return this._unpackListWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === LIST_32) {\n      return this._unpackListWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackListWithSize = function (size, buffer) {\n    var value = [];\n    for (var i = 0; i < size; i++) {\n      value.push(this.unpack(buffer));\n    }\n    return value;\n  };\n  Unpacker.prototype._unpackByteArray = function (marker, buffer) {\n    if (marker === BYTES_8) {\n      return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === BYTES_16) {\n      return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === BYTES_32) {\n      return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackByteArrayWithSize = function (size, buffer) {\n    var value = new Int8Array(size);\n    for (var i = 0; i < size; i++) {\n      value[i] = buffer.readInt8();\n    }\n    return value;\n  };\n  Unpacker.prototype._unpackMap = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_MAP) {\n      return this._unpackMapWithSize(markerLow, buffer);\n    } else if (marker === MAP_8) {\n      return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === MAP_16) {\n      return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === MAP_32) {\n      return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackMapWithSize = function (size, buffer) {\n    var value = {};\n    for (var i = 0; i < size; i++) {\n      var key = this.unpack(buffer);\n      value[key] = this.unpack(buffer);\n    }\n    return value;\n  };\n  Unpacker.prototype._unpackStruct = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_STRUCT) {\n      return this._unpackStructWithSize(markerLow, buffer);\n    } else if (marker === STRUCT_8) {\n      return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === STRUCT_16) {\n      return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n    } else {\n      return null;\n    }\n  };\n  Unpacker.prototype._unpackStructWithSize = function (structSize, buffer) {\n    var signature = buffer.readUInt8();\n    if (signature === NODE) {\n      return this._unpackNode(structSize, buffer);\n    } else if (signature === RELATIONSHIP) {\n      return this._unpackRelationship(structSize, buffer);\n    } else if (signature === UNBOUND_RELATIONSHIP) {\n      return this._unpackUnboundRelationship(structSize, buffer);\n    } else if (signature === PATH) {\n      return this._unpackPath(structSize, buffer);\n    } else {\n      return this._unpackUnknownStruct(signature, structSize, buffer);\n    }\n  };\n  Unpacker.prototype._unpackNode = function (structSize, buffer) {\n    this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.Node(this.unpack(buffer),\n    // Identity\n    this.unpack(buffer),\n    // Labels\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackRelationship = function (structSize, buffer) {\n    this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.Relationship(this.unpack(buffer),\n    // Identity\n    this.unpack(buffer),\n    // Start Node Identity\n    this.unpack(buffer),\n    // End Node Identity\n    this.unpack(buffer),\n    // Type\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackUnboundRelationship = function (structSize, buffer) {\n    this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.UnboundRelationship(this.unpack(buffer),\n    // Identity\n    this.unpack(buffer),\n    // Type\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackPath = function (structSize, buffer) {\n    this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n    var nodes = this.unpack(buffer);\n    var rels = this.unpack(buffer);\n    var sequence = this.unpack(buffer);\n    var segments = [];\n    var prevNode = nodes[0];\n    for (var i = 0; i < sequence.length; i += 2) {\n      var nextNode = nodes[sequence[i + 1]];\n      var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n      var rel = void 0;\n      if (relIndex > 0) {\n        rel = rels[relIndex - 1];\n        if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n          // To avoid duplication, relationships in a path do not contain\n          // information about their start and end nodes, that's instead\n          // inferred from the path sequence. This is us inferring (and,\n          // for performance reasons remembering) the start/end of a rel.\n          rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n        }\n      } else {\n        rel = rels[-relIndex - 1];\n        if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n          // See above\n          rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n        }\n      }\n      // Done hydrating one path segment.\n      segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n      prevNode = nextNode;\n    }\n    return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n  };\n  Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n    var result = new Structure(signature, []);\n    for (var i = 0; i < structSize; i++) {\n      result.fields.push(this.unpack(buffer));\n    }\n    return result;\n  };\n  Unpacker.prototype._verifyStructSize = function (structName, expectedSize, actualSize) {\n    if (expectedSize !== actualSize) {\n      throw (0, neo4j_driver_core_1.newError)(\"Wrong struct size for \" + structName + \", expected \" + expectedSize + \" but was \" + actualSize, PROTOCOL_ERROR);\n    }\n  };\n  return Unpacker;\n}();\nexports.Unpacker = Unpacker;\nfunction isIterable(obj) {\n  if (obj == null) {\n    return false;\n  }\n  return typeof obj[Symbol.iterator] === 'function';\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Structure","Unpacker","Packer","channel_1","require","neo4j_driver_core_1","PROTOCOL_ERROR","error","TINY_STRING","TINY_LIST","TINY_MAP","TINY_STRUCT","NULL","FLOAT_64","FALSE","TRUE","INT_8","INT_16","INT_32","INT_64","STRING_8","STRING_16","STRING_32","LIST_8","LIST_16","LIST_32","BYTES_8","BYTES_16","BYTES_32","MAP_8","MAP_16","MAP_32","STRUCT_8","STRUCT_16","NODE","NODE_STRUCT_SIZE","RELATIONSHIP","RELATIONSHIP_STRUCT_SIZE","UNBOUND_RELATIONSHIP","UNBOUND_RELATIONSHIP_STRUCT_SIZE","PATH","PATH_STRUCT_SIZE","signature","fields","prototype","toString","fieldStr","i","length","channel","_ch","_byteArraysSupported","packable","x","_this","writeUInt8","packFloat","packString","packInteger","int","isInt","Int8Array","packBytes","Array","packListHeader","i_1","undefined","isIterable","packableIterable","Node","_nonPackableValue","Relationship","Path","packableFields","packStruct","keys","count","i_2","packMapHeader","i_3","key","iterable","array","from","e","newError","message","packStructHeader","high","low","greaterThanOrEqual","lessThan","writeInt8","writeInt16","writeInt32","writeFloat64","bytes","utf8","encode","size","writeBytes","packBytesHeader","disableByteArrays","disableLosslessIntegers","useBigInt","_disableLosslessIntegers","_useBigInt","unpack","buffer","marker","readUInt8","markerHigh","markerLow","boolean","_unpackBoolean","numberOrInteger","_unpackNumberOrInteger","toBigInt","toNumberOrInfinity","string","_unpackString","list","_unpackList","byteArray","_unpackByteArray","map","_unpackMap","struct","_unpackStruct","unpackInteger","result","_unpackInteger","readFloat64","readInt8","readInt16","b","readInt32","Integer","decode","readUInt16","readUInt32","_unpackListWithSize","push","_unpackByteArrayWithSize","_unpackMapWithSize","_unpackStructWithSize","structSize","_unpackNode","_unpackRelationship","_unpackUnboundRelationship","_unpackPath","_unpackUnknownStruct","_verifyStructSize","UnboundRelationship","nodes","rels","sequence","segments","prevNode","nextNode","relIndex","toNumber","rel","bind","identity","PathSegment","structName","expectedSize","actualSize","obj","Symbol","iterator"],"sources":["C:/Stanford/DigitalTracesApp3/node_modules/neo4j-driver-bolt-connection/lib/packstream/packstream-v1.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar channel_1 = require(\"../channel\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\nvar Structure = /** @class */ (function () {\n    /**\n     * Create new instance\n     */\n    function Structure(signature, fields) {\n        this.signature = signature;\n        this.fields = fields;\n    }\n    Structure.prototype.toString = function () {\n        var fieldStr = '';\n        for (var i = 0; i < this.fields.length; i++) {\n            if (i > 0) {\n                fieldStr += ', ';\n            }\n            fieldStr += this.fields[i];\n        }\n        return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n    };\n    return Structure;\n}());\nexports.Structure = Structure;\n/**\n * Class to pack\n * @access private\n */\nvar Packer = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Chunker} channel the chunker backed by a network channel.\n     */\n    function Packer(channel) {\n        this._ch = channel;\n        this._byteArraysSupported = true;\n    }\n    /**\n     * Creates a packable function out of the provided value\n     * @param x the value to pack\n     * @returns Function\n     */\n    Packer.prototype.packable = function (x) {\n        var _this = this;\n        if (x === null) {\n            return function () { return _this._ch.writeUInt8(NULL); };\n        }\n        else if (x === true) {\n            return function () { return _this._ch.writeUInt8(TRUE); };\n        }\n        else if (x === false) {\n            return function () { return _this._ch.writeUInt8(FALSE); };\n        }\n        else if (typeof x === 'number') {\n            return function () { return _this.packFloat(x); };\n        }\n        else if (typeof x === 'string') {\n            return function () { return _this.packString(x); };\n        }\n        else if (typeof x === 'bigint') {\n            return function () { return _this.packInteger((0, neo4j_driver_core_1.int)(x)); };\n        }\n        else if ((0, neo4j_driver_core_1.isInt)(x)) {\n            return function () { return _this.packInteger(x); };\n        }\n        else if (x instanceof Int8Array) {\n            return function () { return _this.packBytes(x); };\n        }\n        else if (x instanceof Array) {\n            return function () {\n                _this.packListHeader(x.length);\n                for (var i_1 = 0; i_1 < x.length; i_1++) {\n                    _this.packable(x[i_1] === undefined ? null : x[i_1])();\n                }\n            };\n        }\n        else if (isIterable(x)) {\n            return this.packableIterable(x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Node) {\n            return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \" + x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Relationship) {\n            return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \" + x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Path) {\n            return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \" + x);\n        }\n        else if (x instanceof Structure) {\n            var packableFields = [];\n            for (var i = 0; i < x.fields.length; i++) {\n                packableFields[i] = this.packable(x.fields[i]);\n            }\n            return function () { return _this.packStruct(x.signature, packableFields); };\n        }\n        else if (typeof x === 'object') {\n            return function () {\n                var keys = Object.keys(x);\n                var count = 0;\n                for (var i_2 = 0; i_2 < keys.length; i_2++) {\n                    if (x[keys[i_2]] !== undefined) {\n                        count++;\n                    }\n                }\n                _this.packMapHeader(count);\n                for (var i_3 = 0; i_3 < keys.length; i_3++) {\n                    var key = keys[i_3];\n                    if (x[key] !== undefined) {\n                        _this.packString(key);\n                        _this.packable(x[key])();\n                    }\n                }\n            };\n        }\n        else {\n            return this._nonPackableValue(\"Unable to pack the given value: \" + x);\n        }\n    };\n    Packer.prototype.packableIterable = function (iterable) {\n        try {\n            var array = Array.from(iterable);\n            return this.packable(array);\n        }\n        catch (e) {\n            // handle errors from iterable to array conversion\n            throw (0, neo4j_driver_core_1.newError)(\"Cannot pack given iterable, \" + e.message + \": \" + iterable);\n        }\n    };\n    /**\n     * Packs a struct\n     * @param signature the signature of the struct\n     * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n     */\n    Packer.prototype.packStruct = function (signature, packableFields) {\n        packableFields = packableFields || [];\n        this.packStructHeader(packableFields.length, signature);\n        for (var i = 0; i < packableFields.length; i++) {\n            packableFields[i]();\n        }\n    };\n    Packer.prototype.packInteger = function (x) {\n        var high = x.high;\n        var low = x.low;\n        if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n            this._ch.writeInt8(low);\n        }\n        else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n            this._ch.writeUInt8(INT_8);\n            this._ch.writeInt8(low);\n        }\n        else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n            this._ch.writeUInt8(INT_16);\n            this._ch.writeInt16(low);\n        }\n        else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n            this._ch.writeUInt8(INT_32);\n            this._ch.writeInt32(low);\n        }\n        else {\n            this._ch.writeUInt8(INT_64);\n            this._ch.writeInt32(high);\n            this._ch.writeInt32(low);\n        }\n    };\n    Packer.prototype.packFloat = function (x) {\n        this._ch.writeUInt8(FLOAT_64);\n        this._ch.writeFloat64(x);\n    };\n    Packer.prototype.packString = function (x) {\n        var bytes = channel_1.utf8.encode(x);\n        var size = bytes.length;\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_STRING | size);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(STRING_8);\n            this._ch.writeUInt8(size);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(STRING_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(STRING_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n            this._ch.writeBytes(bytes);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('UTF-8 strings of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packListHeader = function (size) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_LIST | size);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(LIST_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(LIST_16);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(LIST_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Lists of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packBytes = function (array) {\n        if (this._byteArraysSupported) {\n            this.packBytesHeader(array.length);\n            for (var i = 0; i < array.length; i++) {\n                this._ch.writeInt8(array[i]);\n            }\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Byte arrays are not supported by the database this driver is connected to');\n        }\n    };\n    Packer.prototype.packBytesHeader = function (size) {\n        if (size < 0x100) {\n            this._ch.writeUInt8(BYTES_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(BYTES_16);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(BYTES_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Byte arrays of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packMapHeader = function (size) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_MAP | size);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(MAP_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(MAP_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(MAP_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Maps of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packStructHeader = function (size, signature) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_STRUCT | size);\n            this._ch.writeUInt8(signature);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(STRUCT_8);\n            this._ch.writeUInt8(size);\n            this._ch.writeUInt8(signature);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(STRUCT_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Structures of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.disableByteArrays = function () {\n        this._byteArraysSupported = false;\n    };\n    Packer.prototype._nonPackableValue = function (message) {\n        return function () {\n            throw (0, neo4j_driver_core_1.newError)(message, PROTOCOL_ERROR);\n        };\n    };\n    return Packer;\n}());\nexports.Packer = Packer;\n/**\n * Class to unpack\n * @access private\n */\nvar Unpacker = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n     * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n     */\n    function Unpacker(disableLosslessIntegers, useBigInt) {\n        if (disableLosslessIntegers === void 0) { disableLosslessIntegers = false; }\n        if (useBigInt === void 0) { useBigInt = false; }\n        this._disableLosslessIntegers = disableLosslessIntegers;\n        this._useBigInt = useBigInt;\n    }\n    Unpacker.prototype.unpack = function (buffer) {\n        var marker = buffer.readUInt8();\n        var markerHigh = marker & 0xf0;\n        var markerLow = marker & 0x0f;\n        if (marker === NULL) {\n            return null;\n        }\n        var boolean = this._unpackBoolean(marker);\n        if (boolean !== null) {\n            return boolean;\n        }\n        var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n        if (numberOrInteger !== null) {\n            if ((0, neo4j_driver_core_1.isInt)(numberOrInteger)) {\n                if (this._useBigInt) {\n                    return numberOrInteger.toBigInt();\n                }\n                else if (this._disableLosslessIntegers) {\n                    return numberOrInteger.toNumberOrInfinity();\n                }\n            }\n            return numberOrInteger;\n        }\n        var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n        if (string !== null) {\n            return string;\n        }\n        var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n        if (list !== null) {\n            return list;\n        }\n        var byteArray = this._unpackByteArray(marker, buffer);\n        if (byteArray !== null) {\n            return byteArray;\n        }\n        var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n        if (map !== null) {\n            return map;\n        }\n        var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n        if (struct !== null) {\n            return struct;\n        }\n        throw (0, neo4j_driver_core_1.newError)('Unknown packed value with marker ' + marker.toString(16));\n    };\n    Unpacker.prototype.unpackInteger = function (buffer) {\n        var marker = buffer.readUInt8();\n        var result = this._unpackInteger(marker, buffer);\n        if (result == null) {\n            throw (0, neo4j_driver_core_1.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n        }\n        return result;\n    };\n    Unpacker.prototype._unpackBoolean = function (marker) {\n        if (marker === TRUE) {\n            return true;\n        }\n        else if (marker === FALSE) {\n            return false;\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackNumberOrInteger = function (marker, buffer) {\n        if (marker === FLOAT_64) {\n            return buffer.readFloat64();\n        }\n        else {\n            return this._unpackInteger(marker, buffer);\n        }\n    };\n    Unpacker.prototype._unpackInteger = function (marker, buffer) {\n        if (marker >= 0 && marker < 128) {\n            return (0, neo4j_driver_core_1.int)(marker);\n        }\n        else if (marker >= 240 && marker < 256) {\n            return (0, neo4j_driver_core_1.int)(marker - 256);\n        }\n        else if (marker === INT_8) {\n            return (0, neo4j_driver_core_1.int)(buffer.readInt8());\n        }\n        else if (marker === INT_16) {\n            return (0, neo4j_driver_core_1.int)(buffer.readInt16());\n        }\n        else if (marker === INT_32) {\n            var b = buffer.readInt32();\n            return (0, neo4j_driver_core_1.int)(b);\n        }\n        else if (marker === INT_64) {\n            var high = buffer.readInt32();\n            var low = buffer.readInt32();\n            return new neo4j_driver_core_1.Integer(low, high);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackString = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_STRING) {\n            return channel_1.utf8.decode(buffer, markerLow);\n        }\n        else if (marker === STRING_8) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt8());\n        }\n        else if (marker === STRING_16) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt16());\n        }\n        else if (marker === STRING_32) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt32());\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackList = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_LIST) {\n            return this._unpackListWithSize(markerLow, buffer);\n        }\n        else if (marker === LIST_8) {\n            return this._unpackListWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === LIST_16) {\n            return this._unpackListWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === LIST_32) {\n            return this._unpackListWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackListWithSize = function (size, buffer) {\n        var value = [];\n        for (var i = 0; i < size; i++) {\n            value.push(this.unpack(buffer));\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackByteArray = function (marker, buffer) {\n        if (marker === BYTES_8) {\n            return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === BYTES_16) {\n            return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === BYTES_32) {\n            return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackByteArrayWithSize = function (size, buffer) {\n        var value = new Int8Array(size);\n        for (var i = 0; i < size; i++) {\n            value[i] = buffer.readInt8();\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackMap = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_MAP) {\n            return this._unpackMapWithSize(markerLow, buffer);\n        }\n        else if (marker === MAP_8) {\n            return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === MAP_16) {\n            return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === MAP_32) {\n            return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackMapWithSize = function (size, buffer) {\n        var value = {};\n        for (var i = 0; i < size; i++) {\n            var key = this.unpack(buffer);\n            value[key] = this.unpack(buffer);\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackStruct = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_STRUCT) {\n            return this._unpackStructWithSize(markerLow, buffer);\n        }\n        else if (marker === STRUCT_8) {\n            return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === STRUCT_16) {\n            return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackStructWithSize = function (structSize, buffer) {\n        var signature = buffer.readUInt8();\n        if (signature === NODE) {\n            return this._unpackNode(structSize, buffer);\n        }\n        else if (signature === RELATIONSHIP) {\n            return this._unpackRelationship(structSize, buffer);\n        }\n        else if (signature === UNBOUND_RELATIONSHIP) {\n            return this._unpackUnboundRelationship(structSize, buffer);\n        }\n        else if (signature === PATH) {\n            return this._unpackPath(structSize, buffer);\n        }\n        else {\n            return this._unpackUnknownStruct(signature, structSize, buffer);\n        }\n    };\n    Unpacker.prototype._unpackNode = function (structSize, buffer) {\n        this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.Node(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Labels\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackRelationship = function (structSize, buffer) {\n        this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.Relationship(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Start Node Identity\n        this.unpack(buffer), // End Node Identity\n        this.unpack(buffer), // Type\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackUnboundRelationship = function (structSize, buffer) {\n        this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.UnboundRelationship(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Type\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackPath = function (structSize, buffer) {\n        this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n        var nodes = this.unpack(buffer);\n        var rels = this.unpack(buffer);\n        var sequence = this.unpack(buffer);\n        var segments = [];\n        var prevNode = nodes[0];\n        for (var i = 0; i < sequence.length; i += 2) {\n            var nextNode = nodes[sequence[i + 1]];\n            var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n            var rel = void 0;\n            if (relIndex > 0) {\n                rel = rels[relIndex - 1];\n                if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n                    // To avoid duplication, relationships in a path do not contain\n                    // information about their start and end nodes, that's instead\n                    // inferred from the path sequence. This is us inferring (and,\n                    // for performance reasons remembering) the start/end of a rel.\n                    rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n                }\n            }\n            else {\n                rel = rels[-relIndex - 1];\n                if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n                    // See above\n                    rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n                }\n            }\n            // Done hydrating one path segment.\n            segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n            prevNode = nextNode;\n        }\n        return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n    };\n    Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n        var result = new Structure(signature, []);\n        for (var i = 0; i < structSize; i++) {\n            result.fields.push(this.unpack(buffer));\n        }\n        return result;\n    };\n    Unpacker.prototype._verifyStructSize = function (structName, expectedSize, actualSize) {\n        if (expectedSize !== actualSize) {\n            throw (0, neo4j_driver_core_1.newError)(\"Wrong struct size for \" + structName + \", expected \" + expectedSize + \" but was \" + actualSize, PROTOCOL_ERROR);\n        }\n    };\n    return Unpacker;\n}());\nexports.Unpacker = Unpacker;\nfunction isIterable(obj) {\n    if (obj == null) {\n        return false;\n    }\n    return typeof obj[Symbol.iterator] === 'function';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}