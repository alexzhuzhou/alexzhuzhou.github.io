{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar util_1 = require(\"./internal/util\");\nvar connection_holder_1 = require(\"./internal/connection-holder\");\nvar bookmark_1 = require(\"./internal/bookmark\");\nvar tx_config_1 = require(\"./internal/tx-config\");\nvar observers_1 = require(\"./internal/observers\");\nvar error_1 = require(\"./error\");\nvar result_1 = __importDefault(require(\"./result\"));\n/**\n * Represents a transaction in the Neo4j database.\n *\n * @access public\n */\nvar Transaction = /** @class */function () {\n  /**\n   * @constructor\n   * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.\n   * @param {function()} onClose - Function to be called when transaction is committed or rolled back.\n   * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.\n   * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton\n   * is not yet released.\n   * @param {boolean} reactive whether this transaction generates reactive streams\n   * @param {number} fetchSize - the record fetch size in each pulling batch.\n   * @param {string} impersonatedUser - The name of the user which should be impersonated for the duration of the session.\n   */\n  function Transaction(_a) {\n    var connectionHolder = _a.connectionHolder,\n      onClose = _a.onClose,\n      onBookmark = _a.onBookmark,\n      onConnection = _a.onConnection,\n      reactive = _a.reactive,\n      fetchSize = _a.fetchSize,\n      impersonatedUser = _a.impersonatedUser;\n    this._connectionHolder = connectionHolder;\n    this._reactive = reactive;\n    this._state = _states.ACTIVE;\n    this._onClose = onClose;\n    this._onBookmark = onBookmark;\n    this._onConnection = onConnection;\n    this._onError = this._onErrorCallback.bind(this);\n    this._onComplete = this._onCompleteCallback.bind(this);\n    this._fetchSize = fetchSize;\n    this._results = [];\n    this._impersonatedUser = impersonatedUser;\n  }\n  /**\n   * @private\n   * @param {Bookmark | string |  string []} bookmark\n   * @param {TxConfig} txConfig\n   * @returns {void}\n   */\n  Transaction.prototype._begin = function (bookmark, txConfig) {\n    var _this = this;\n    this._connectionHolder.getConnection().then(function (connection) {\n      _this._onConnection();\n      if (connection) {\n        return connection.protocol().beginTransaction({\n          bookmark: bookmark,\n          txConfig: txConfig,\n          mode: _this._connectionHolder.mode(),\n          database: _this._connectionHolder.database(),\n          impersonatedUser: _this._impersonatedUser,\n          beforeError: _this._onError,\n          afterComplete: _this._onComplete\n        });\n      } else {\n        throw (0, error_1.newError)('No connection available');\n      }\n    }).catch(function (error) {\n      return _this._onError(error);\n    });\n  };\n  /**\n   * Run Cypher query\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n   * or with the query and parameters as separate arguments.\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @return {Result} New Result\n   */\n  Transaction.prototype.run = function (query, parameters) {\n    var _a = (0, util_1.validateQueryAndParameters)(query, parameters),\n      validatedQuery = _a.validatedQuery,\n      params = _a.params;\n    var result = this._state.run(validatedQuery, params, {\n      connectionHolder: this._connectionHolder,\n      onError: this._onError,\n      onComplete: this._onComplete,\n      onConnection: this._onConnection,\n      reactive: this._reactive,\n      fetchSize: this._fetchSize\n    });\n    this._results.push(result);\n    return result;\n  };\n  /**\n   * Commits the transaction and returns the result.\n   *\n   * After committing the transaction can no longer be used.\n   *\n   * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.\n   */\n  Transaction.prototype.commit = function () {\n    var committed = this._state.commit({\n      connectionHolder: this._connectionHolder,\n      onError: this._onError,\n      onComplete: this._onComplete,\n      onConnection: this._onConnection,\n      pendingResults: this._results\n    });\n    this._state = committed.state;\n    // clean up\n    this._onClose();\n    return new Promise(function (resolve, reject) {\n      committed.result.subscribe({\n        onCompleted: function onCompleted() {\n          return resolve();\n        },\n        onError: function onError(error) {\n          return reject(error);\n        }\n      });\n    });\n  };\n  /**\n   * Rollbacks the transaction.\n   *\n   * After rolling back, the transaction can no longer be used.\n   *\n   * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during\n   * rollback.\n   */\n  Transaction.prototype.rollback = function () {\n    var rolledback = this._state.rollback({\n      connectionHolder: this._connectionHolder,\n      onError: this._onError,\n      onComplete: this._onComplete,\n      onConnection: this._onConnection,\n      pendingResults: this._results\n    });\n    this._state = rolledback.state;\n    // clean up\n    this._onClose();\n    return new Promise(function (resolve, reject) {\n      rolledback.result.subscribe({\n        onCompleted: function onCompleted() {\n          return resolve();\n        },\n        onError: function onError(error) {\n          return reject(error);\n        }\n      });\n    });\n  };\n  /**\n   * Check if this transaction is active, which means commit and rollback did not happen.\n   * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.\n   */\n  Transaction.prototype.isOpen = function () {\n    return this._state === _states.ACTIVE;\n  };\n  Transaction.prototype._onErrorCallback = function (err) {\n    // error will be \"acknowledged\" by sending a RESET message\n    // database will then forget about this transaction and cleanup all corresponding resources\n    // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it\n    this._state = _states.FAILED;\n    this._onClose();\n    // release connection back to the pool\n    return this._connectionHolder.releaseConnection();\n  };\n  /**\n   * @private\n   * @param {object} meta The meta with bookmark\n   * @returns {void}\n   */\n  Transaction.prototype._onCompleteCallback = function (meta) {\n    this._onBookmark(new bookmark_1.Bookmark(meta.bookmark));\n  };\n  return Transaction;\n}();\nvar _states = {\n  // The transaction is running with no explicit success or failure marked\n  ACTIVE: {\n    commit: function commit(_a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete,\n        onConnection = _a.onConnection,\n        pendingResults = _a.pendingResults;\n      return {\n        result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),\n        state: _states.SUCCEEDED\n      };\n    },\n    rollback: function rollback(_a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete,\n        onConnection = _a.onConnection,\n        pendingResults = _a.pendingResults;\n      return {\n        result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),\n        state: _states.ROLLED_BACK\n      };\n    },\n    run: function run(query, parameters, _a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete,\n        onConnection = _a.onConnection,\n        reactive = _a.reactive,\n        fetchSize = _a.fetchSize;\n      // RUN in explicit transaction can't contain bookmarks and transaction configuration\n      // No need to include mode and database name as it shall be inclued in begin\n      var observerPromise = connectionHolder.getConnection().then(function (conn) {\n        onConnection();\n        if (conn) {\n          return conn.protocol().run(query, parameters, {\n            bookmark: bookmark_1.Bookmark.empty(),\n            txConfig: tx_config_1.TxConfig.empty(),\n            beforeError: onError,\n            afterComplete: onComplete,\n            reactive: reactive,\n            fetchSize: fetchSize\n          });\n        } else {\n          throw (0, error_1.newError)('No connection available');\n        }\n      }).catch(function (error) {\n        return new observers_1.FailedObserver({\n          error: error,\n          onError: onError\n        });\n      });\n      return newCompletedResult(observerPromise, query, parameters, connectionHolder);\n    }\n  },\n  // An error has occurred, transaction can no longer be used and no more messages will\n  // be sent for this transaction.\n  FAILED: {\n    commit: function commit(_a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),\n          onError: onError\n        }), 'COMMIT', {}, connectionHolder),\n        state: _states.FAILED\n      };\n    },\n    rollback: function rollback(_a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.CompletedObserver(), 'ROLLBACK', {}, connectionHolder),\n        state: _states.FAILED\n      };\n    },\n    run: function run(query, parameters, _a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return newCompletedResult(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),\n        onError: onError\n      }), query, parameters, connectionHolder);\n    }\n  },\n  // This transaction has successfully committed\n  SUCCEEDED: {\n    commit: function commit(_a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot commit this transaction, because it has already been committed.'),\n          onError: onError\n        }), 'COMMIT', {}),\n        state: _states.SUCCEEDED,\n        connectionHolder: connectionHolder\n      };\n    },\n    rollback: function rollback(_a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been committed.'),\n          onError: onError\n        }), 'ROLLBACK', {}),\n        state: _states.SUCCEEDED,\n        connectionHolder: connectionHolder\n      };\n    },\n    run: function run(query, parameters, _a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return newCompletedResult(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been committed.'),\n        onError: onError\n      }), query, parameters, connectionHolder);\n    }\n  },\n  // This transaction has been rolled back\n  ROLLED_BACK: {\n    commit: function commit(_a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot commit this transaction, because it has already been rolled back.'),\n          onError: onError\n        }), 'COMMIT', {}, connectionHolder),\n        state: _states.ROLLED_BACK\n      };\n    },\n    rollback: function rollback(_a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return {\n        result: newCompletedResult(new observers_1.FailedObserver({\n          error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been rolled back.')\n        }), 'ROLLBACK', {}, connectionHolder),\n        state: _states.ROLLED_BACK\n      };\n    },\n    run: function run(query, parameters, _a) {\n      var connectionHolder = _a.connectionHolder,\n        onError = _a.onError,\n        onComplete = _a.onComplete;\n      return newCompletedResult(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been rolled back.'),\n        onError: onError\n      }), query, parameters, connectionHolder);\n    }\n  }\n};\n/**\n *\n * @param {boolean} commit\n * @param {ConnectionHolder} connectionHolder\n * @param {function(err:Error): any} onError\n * @param {function(metadata:object): any} onComplete\n * @param {function() : any} onConnection\n * @param {list<Result>>}pendingResults all run results in this transaction\n */\nfunction finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {\n  var observerPromise = connectionHolder.getConnection().then(function (connection) {\n    onConnection();\n    pendingResults.forEach(function (r) {\n      return r._cancel();\n    });\n    return Promise.all(pendingResults).then(function (results) {\n      if (connection) {\n        if (commit) {\n          return connection.protocol().commitTransaction({\n            beforeError: onError,\n            afterComplete: onComplete\n          });\n        } else {\n          return connection.protocol().rollbackTransaction({\n            beforeError: onError,\n            afterComplete: onComplete\n          });\n        }\n      } else {\n        throw (0, error_1.newError)('No connection available');\n      }\n    });\n  }).catch(function (error) {\n    return new observers_1.FailedObserver({\n      error: error,\n      onError: onError\n    });\n  });\n  // for commit & rollback we need result that uses real connection holder and notifies it when\n  // connection is not needed and can be safely released to the pool\n  return new result_1.default(observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);\n}\n/**\n * Creates a {@link Result} with empty connection holder.\n * For cases when result represents an intermediate or failed action, does not require any metadata and does not\n * need to influence real connection holder to release connections.\n * @param {ResultStreamObserver} observer - an observer for the created result.\n * @param {string} query - the cypher query that produced the result.\n * @param {Object} parameters - the parameters for cypher query that produced the result.\n * @param {ConnectionHolder} connectionHolder - the connection holder used to get the result\n * @return {Result} new result.\n * @private\n */\nfunction newCompletedResult(observerPromise, query, parameters, connectionHolder) {\n  if (connectionHolder === void 0) {\n    connectionHolder = connection_holder_1.EMPTY_CONNECTION_HOLDER;\n  }\n  return new result_1.default(Promise.resolve(observerPromise), query, parameters, new connection_holder_1.ReadOnlyConnectionHolder(connectionHolder || connection_holder_1.EMPTY_CONNECTION_HOLDER));\n}\nexports.default = Transaction;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","util_1","require","connection_holder_1","bookmark_1","tx_config_1","observers_1","error_1","result_1","Transaction","_a","connectionHolder","onClose","onBookmark","onConnection","reactive","fetchSize","impersonatedUser","_connectionHolder","_reactive","_state","_states","ACTIVE","_onClose","_onBookmark","_onConnection","_onError","_onErrorCallback","bind","_onComplete","_onCompleteCallback","_fetchSize","_results","_impersonatedUser","prototype","_begin","bookmark","txConfig","_this","getConnection","then","connection","protocol","beginTransaction","mode","database","beforeError","afterComplete","newError","catch","error","run","query","parameters","validateQueryAndParameters","validatedQuery","params","result","onError","onComplete","push","commit","committed","pendingResults","state","Promise","resolve","reject","subscribe","onCompleted","rollback","rolledback","isOpen","err","FAILED","releaseConnection","meta","Bookmark","finishTransaction","SUCCEEDED","ROLLED_BACK","observerPromise","conn","empty","TxConfig","FailedObserver","newCompletedResult","CompletedObserver","forEach","r","_cancel","all","results","commitTransaction","rollbackTransaction","default","EMPTY_CONNECTION_HOLDER","ReadOnlyConnectionHolder"],"sources":["C:/Stanford/DigitalTracesApp3/node_modules/neo4j-driver-core/lib/transaction.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar util_1 = require(\"./internal/util\");\nvar connection_holder_1 = require(\"./internal/connection-holder\");\nvar bookmark_1 = require(\"./internal/bookmark\");\nvar tx_config_1 = require(\"./internal/tx-config\");\nvar observers_1 = require(\"./internal/observers\");\nvar error_1 = require(\"./error\");\nvar result_1 = __importDefault(require(\"./result\"));\n/**\n * Represents a transaction in the Neo4j database.\n *\n * @access public\n */\nvar Transaction = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.\n     * @param {function()} onClose - Function to be called when transaction is committed or rolled back.\n     * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.\n     * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton\n     * is not yet released.\n     * @param {boolean} reactive whether this transaction generates reactive streams\n     * @param {number} fetchSize - the record fetch size in each pulling batch.\n     * @param {string} impersonatedUser - The name of the user which should be impersonated for the duration of the session.\n     */\n    function Transaction(_a) {\n        var connectionHolder = _a.connectionHolder, onClose = _a.onClose, onBookmark = _a.onBookmark, onConnection = _a.onConnection, reactive = _a.reactive, fetchSize = _a.fetchSize, impersonatedUser = _a.impersonatedUser;\n        this._connectionHolder = connectionHolder;\n        this._reactive = reactive;\n        this._state = _states.ACTIVE;\n        this._onClose = onClose;\n        this._onBookmark = onBookmark;\n        this._onConnection = onConnection;\n        this._onError = this._onErrorCallback.bind(this);\n        this._onComplete = this._onCompleteCallback.bind(this);\n        this._fetchSize = fetchSize;\n        this._results = [];\n        this._impersonatedUser = impersonatedUser;\n    }\n    /**\n     * @private\n     * @param {Bookmark | string |  string []} bookmark\n     * @param {TxConfig} txConfig\n     * @returns {void}\n     */\n    Transaction.prototype._begin = function (bookmark, txConfig) {\n        var _this = this;\n        this._connectionHolder\n            .getConnection()\n            .then(function (connection) {\n            _this._onConnection();\n            if (connection) {\n                return connection.protocol().beginTransaction({\n                    bookmark: bookmark,\n                    txConfig: txConfig,\n                    mode: _this._connectionHolder.mode(),\n                    database: _this._connectionHolder.database(),\n                    impersonatedUser: _this._impersonatedUser,\n                    beforeError: _this._onError,\n                    afterComplete: _this._onComplete\n                });\n            }\n            else {\n                throw (0, error_1.newError)('No connection available');\n            }\n        })\n            .catch(function (error) { return _this._onError(error); });\n    };\n    /**\n     * Run Cypher query\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the query and parameters as separate arguments.\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @return {Result} New Result\n     */\n    Transaction.prototype.run = function (query, parameters) {\n        var _a = (0, util_1.validateQueryAndParameters)(query, parameters), validatedQuery = _a.validatedQuery, params = _a.params;\n        var result = this._state.run(validatedQuery, params, {\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: this._onComplete,\n            onConnection: this._onConnection,\n            reactive: this._reactive,\n            fetchSize: this._fetchSize\n        });\n        this._results.push(result);\n        return result;\n    };\n    /**\n     * Commits the transaction and returns the result.\n     *\n     * After committing the transaction can no longer be used.\n     *\n     * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.\n     */\n    Transaction.prototype.commit = function () {\n        var committed = this._state.commit({\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: this._onComplete,\n            onConnection: this._onConnection,\n            pendingResults: this._results\n        });\n        this._state = committed.state;\n        // clean up\n        this._onClose();\n        return new Promise(function (resolve, reject) {\n            committed.result.subscribe({\n                onCompleted: function () { return resolve(); },\n                onError: function (error) { return reject(error); }\n            });\n        });\n    };\n    /**\n     * Rollbacks the transaction.\n     *\n     * After rolling back, the transaction can no longer be used.\n     *\n     * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during\n     * rollback.\n     */\n    Transaction.prototype.rollback = function () {\n        var rolledback = this._state.rollback({\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: this._onComplete,\n            onConnection: this._onConnection,\n            pendingResults: this._results\n        });\n        this._state = rolledback.state;\n        // clean up\n        this._onClose();\n        return new Promise(function (resolve, reject) {\n            rolledback.result.subscribe({\n                onCompleted: function () { return resolve(); },\n                onError: function (error) { return reject(error); }\n            });\n        });\n    };\n    /**\n     * Check if this transaction is active, which means commit and rollback did not happen.\n     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.\n     */\n    Transaction.prototype.isOpen = function () {\n        return this._state === _states.ACTIVE;\n    };\n    Transaction.prototype._onErrorCallback = function (err) {\n        // error will be \"acknowledged\" by sending a RESET message\n        // database will then forget about this transaction and cleanup all corresponding resources\n        // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it\n        this._state = _states.FAILED;\n        this._onClose();\n        // release connection back to the pool\n        return this._connectionHolder.releaseConnection();\n    };\n    /**\n     * @private\n     * @param {object} meta The meta with bookmark\n     * @returns {void}\n     */\n    Transaction.prototype._onCompleteCallback = function (meta) {\n        this._onBookmark(new bookmark_1.Bookmark(meta.bookmark));\n    };\n    return Transaction;\n}());\nvar _states = {\n    // The transaction is running with no explicit success or failure marked\n    ACTIVE: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, pendingResults = _a.pendingResults;\n            return {\n                result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),\n                state: _states.SUCCEEDED\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, pendingResults = _a.pendingResults;\n            return {\n                result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),\n                state: _states.ROLLED_BACK\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, reactive = _a.reactive, fetchSize = _a.fetchSize;\n            // RUN in explicit transaction can't contain bookmarks and transaction configuration\n            // No need to include mode and database name as it shall be inclued in begin\n            var observerPromise = connectionHolder\n                .getConnection()\n                .then(function (conn) {\n                onConnection();\n                if (conn) {\n                    return conn.protocol().run(query, parameters, {\n                        bookmark: bookmark_1.Bookmark.empty(),\n                        txConfig: tx_config_1.TxConfig.empty(),\n                        beforeError: onError,\n                        afterComplete: onComplete,\n                        reactive: reactive,\n                        fetchSize: fetchSize,\n                    });\n                }\n                else {\n                    throw (0, error_1.newError)('No connection available');\n                }\n            })\n                .catch(function (error) { return new observers_1.FailedObserver({ error: error, onError: onError }); });\n            return newCompletedResult(observerPromise, query, parameters, connectionHolder);\n        }\n    },\n    // An error has occurred, transaction can no longer be used and no more messages will\n    // be sent for this transaction.\n    FAILED: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),\n                    onError: onError\n                }), 'COMMIT', {}, connectionHolder),\n                state: _states.FAILED\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.CompletedObserver(), 'ROLLBACK', {}, connectionHolder),\n                state: _states.FAILED\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),\n                onError: onError\n            }), query, parameters, connectionHolder);\n        }\n    },\n    // This transaction has successfully committed\n    SUCCEEDED: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has already been committed.'),\n                    onError: onError\n                }), 'COMMIT', {}),\n                state: _states.SUCCEEDED,\n                connectionHolder: connectionHolder\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been committed.'),\n                    onError: onError\n                }), 'ROLLBACK', {}),\n                state: _states.SUCCEEDED,\n                connectionHolder: connectionHolder\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been committed.'),\n                onError: onError\n            }), query, parameters, connectionHolder);\n        }\n    },\n    // This transaction has been rolled back\n    ROLLED_BACK: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has already been rolled back.'),\n                    onError: onError\n                }), 'COMMIT', {}, connectionHolder),\n                state: _states.ROLLED_BACK\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been rolled back.')\n                }), 'ROLLBACK', {}, connectionHolder),\n                state: _states.ROLLED_BACK\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been rolled back.'),\n                onError: onError\n            }), query, parameters, connectionHolder);\n        }\n    }\n};\n/**\n *\n * @param {boolean} commit\n * @param {ConnectionHolder} connectionHolder\n * @param {function(err:Error): any} onError\n * @param {function(metadata:object): any} onComplete\n * @param {function() : any} onConnection\n * @param {list<Result>>}pendingResults all run results in this transaction\n */\nfunction finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {\n    var observerPromise = connectionHolder\n        .getConnection()\n        .then(function (connection) {\n        onConnection();\n        pendingResults.forEach(function (r) { return r._cancel(); });\n        return Promise.all(pendingResults).then(function (results) {\n            if (connection) {\n                if (commit) {\n                    return connection.protocol().commitTransaction({\n                        beforeError: onError,\n                        afterComplete: onComplete\n                    });\n                }\n                else {\n                    return connection.protocol().rollbackTransaction({\n                        beforeError: onError,\n                        afterComplete: onComplete\n                    });\n                }\n            }\n            else {\n                throw (0, error_1.newError)('No connection available');\n            }\n        });\n    })\n        .catch(function (error) { return new observers_1.FailedObserver({ error: error, onError: onError }); });\n    // for commit & rollback we need result that uses real connection holder and notifies it when\n    // connection is not needed and can be safely released to the pool\n    return new result_1.default(observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);\n}\n/**\n * Creates a {@link Result} with empty connection holder.\n * For cases when result represents an intermediate or failed action, does not require any metadata and does not\n * need to influence real connection holder to release connections.\n * @param {ResultStreamObserver} observer - an observer for the created result.\n * @param {string} query - the cypher query that produced the result.\n * @param {Object} parameters - the parameters for cypher query that produced the result.\n * @param {ConnectionHolder} connectionHolder - the connection holder used to get the result\n * @return {Result} new result.\n * @private\n */\nfunction newCompletedResult(observerPromise, query, parameters, connectionHolder) {\n    if (connectionHolder === void 0) { connectionHolder = connection_holder_1.EMPTY_CONNECTION_HOLDER; }\n    return new result_1.default(Promise.resolve(observerPromise), query, parameters, new connection_holder_1.ReadOnlyConnectionHolder(connectionHolder || connection_holder_1.EMPTY_CONNECTION_HOLDER));\n}\nexports.default = Transaction;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}