{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WRITE = exports.READ = exports.Driver = void 0;\nvar bookmark_1 = require(\"./internal/bookmark\");\nvar connectivity_verifier_1 = require(\"./internal/connectivity-verifier\");\nvar configured_custom_resolver_1 = __importDefault(require(\"./internal/resolver/configured-custom-resolver\"));\nvar constants_1 = require(\"./internal/constants\");\nvar logger_1 = require(\"./internal/logger\");\nvar session_1 = __importDefault(require(\"./session\"));\nvar util_1 = require(\"./internal/util\");\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\n/**\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\n * @type {number}\n */\nvar DEFAULT_FETCH_SIZE = 1000;\n/**\n * Constant that represents read session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\n * @type {string}\n */\nvar READ = constants_1.ACCESS_MODE_READ;\nexports.READ = READ;\n/**\n * Constant that represents write session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\n * @type {string}\n */\nvar WRITE = constants_1.ACCESS_MODE_WRITE;\nexports.WRITE = WRITE;\nvar idGenerator = 0;\n/**\n * A driver maintains one or more {@link Session}s with a remote\n * Neo4j instance. Through the {@link Session}s you can send queries\n * and retrieve results from the database.\n *\n * Drivers are reasonably expensive to create - you should strive to keep one\n * driver instance around per Neo4j Instance you connect to.\n *\n * @access public\n */\nvar Driver = /** @class */function () {\n  /**\n   * You should not be calling this directly, instead use {@link driver}.\n   * @constructor\n   * @protected\n   * @param {Object} meta Metainformation about the driver\n   * @param {Object} config\n   * @param {function(id: number, config:Object, log:Logger, hostNameResolver: ConfiguredCustomResolver): ConnectionProvider } createConnectonProvider Creates the connection provider\n   * @param {function(args): Session } createSession Creates the a session\n  */\n  function Driver(meta, config, createConnectonProvider, createSession) {\n    if (config === void 0) {\n      config = {};\n    }\n    if (createSession === void 0) {\n      createSession = function createSession(args) {\n        return new session_1.default(args);\n      };\n    }\n    sanitizeConfig(config);\n    validateConfig(config);\n    this._id = idGenerator++;\n    this._meta = meta;\n    this._config = config;\n    this._log = logger_1.Logger.create(config);\n    this._createConnectionProvider = createConnectonProvider;\n    this._createSession = createSession;\n    /**\n     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\n     * @type {ConnectionProvider}\n     * @protected\n     */\n    this._connectionProvider = null;\n    this._afterConstruction();\n  }\n  /**\n   * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\n   *\n   * @public\n   * @param {Object} param - The object parameter\n   * @param {string} param.database - The target database to verify connectivity for.\n   * @returns {Promise<ServerInfo>} promise resolved with server info or rejected with error.\n   */\n  Driver.prototype.verifyConnectivity = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.database,\n      database = _c === void 0 ? '' : _c;\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    var connectivityVerifier = new connectivity_verifier_1.ConnectivityVerifier(connectionProvider);\n    return connectivityVerifier.verify({\n      database: database\n    });\n  };\n  /**\n   * Returns whether the server supports multi database capabilities based on the protocol\n   * version negotiated via handshake.\n   *\n   * Note that this function call _always_ causes a round-trip to the server.\n   *\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n   */\n  Driver.prototype.supportsMultiDb = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.supportsMultiDb();\n  };\n  /**\n   * Returns whether the server supports transaction config capabilities based on the protocol\n   * version negotiated via handshake.\n   *\n   * Note that this function call _always_ causes a round-trip to the server.\n   *\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n   */\n  Driver.prototype.supportsTransactionConfig = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.supportsTransactionConfig();\n  };\n  /**\n   * Returns whether the server supports user impersonation capabilities based on the protocol\n   * version negotiated via handshake.\n   *\n   * Note that this function call _always_ causes a round-trip to the server.\n   *\n   * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n   */\n  Driver.prototype.supportsUserImpersonation = function () {\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    return connectionProvider.supportsUserImpersonation();\n  };\n  /**\n   * @protected\n   * @returns {boolean}\n   */\n  Driver.prototype._supportsRouting = function () {\n    return this._meta.routing;\n  };\n  /**\n   * Returns boolean to indicate if driver has been configured with encryption enabled.\n   *\n   * @protected\n   * @returns {boolean}\n   */\n  Driver.prototype._isEncrypted = function () {\n    return this._config.encrypted === util_1.ENCRYPTION_ON;\n  };\n  /**\n   * Returns the configured trust strategy that the driver has been configured with.\n   *\n   * @protected\n   * @returns {TrustStrategy}\n   */\n  Driver.prototype._getTrust = function () {\n    return this._config.trust;\n  };\n  /**\n   * Acquire a session to communicate with the database. The session will\n   * borrow connections from the underlying connection pool as required and\n   * should be considered lightweight and disposable.\n   *\n   * This comes with some responsibility - make sure you always call\n   * {@link close} when you are done using a session, and likewise,\n   * make sure you don't close your session before you are done using it. Once\n   * it is closed, the underlying connection will be released to the connection\n   * pool and made available for others to use.\n   *\n   * @public\n   * @param {Object} param - The object parameter\n   * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\n   * @param {string|string[]} param.bookmarks - The initial reference or references to some previous\n   * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\n   * @param {number} param.fetchSize - The record fetch size of each batch of this session.\n   * Use {@link FETCH_ALL} to always pull all records in one batch. This will override the config value set on driver config.\n   * @param {string} param.database - The database this session will operate on.\n   * @param {string} param.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n   * @return {Session} new session.\n   */\n  Driver.prototype.session = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.defaultAccessMode,\n      defaultAccessMode = _c === void 0 ? WRITE : _c,\n      bookmarkOrBookmarks = _b.bookmarks,\n      _d = _b.database,\n      database = _d === void 0 ? '' : _d,\n      impersonatedUser = _b.impersonatedUser,\n      fetchSize = _b.fetchSize;\n    return this._newSession({\n      defaultAccessMode: defaultAccessMode,\n      bookmarkOrBookmarks: bookmarkOrBookmarks,\n      database: database,\n      reactive: false,\n      impersonatedUser: impersonatedUser,\n      fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)\n    });\n  };\n  /**\n   * Close all open sessions and other associated resources. You should\n   * make sure to use this when you are done with this driver instance.\n   * @public\n   * @return {Promise<void>} promise resolved when the driver is closed.\n   */\n  Driver.prototype.close = function () {\n    this._log.info(\"Driver \" + this._id + \" closing\");\n    if (this._connectionProvider) {\n      return this._connectionProvider.close();\n    }\n    return Promise.resolve();\n  };\n  /**\n   * @protected\n   */\n  Driver.prototype._afterConstruction = function () {\n    this._log.info(this._meta.typename + \" driver \" + this._id + \" created for server address \" + this._meta.address);\n  };\n  /**\n   * @private\n   */\n  Driver.prototype._newSession = function (_a) {\n    var defaultAccessMode = _a.defaultAccessMode,\n      bookmarkOrBookmarks = _a.bookmarkOrBookmarks,\n      database = _a.database,\n      reactive = _a.reactive,\n      impersonatedUser = _a.impersonatedUser,\n      fetchSize = _a.fetchSize;\n    var sessionMode = session_1.default._validateSessionMode(defaultAccessMode);\n    var connectionProvider = this._getOrCreateConnectionProvider();\n    var bookmark = bookmarkOrBookmarks ? new bookmark_1.Bookmark(bookmarkOrBookmarks) : bookmark_1.Bookmark.empty();\n    return this._createSession({\n      mode: sessionMode,\n      database: database || '',\n      connectionProvider: connectionProvider,\n      bookmark: bookmark,\n      config: this._config,\n      reactive: reactive,\n      impersonatedUser: impersonatedUser,\n      fetchSize: fetchSize\n    });\n  };\n  /**\n   * @private\n   */\n  Driver.prototype._getOrCreateConnectionProvider = function () {\n    if (!this._connectionProvider) {\n      this._connectionProvider = this._createConnectionProvider(this._id, this._config, this._log, createHostNameResolver(this._config));\n    }\n    return this._connectionProvider;\n  };\n  return Driver;\n}();\nexports.Driver = Driver;\n/**\n * @private\n * @returns {Object} the given config.\n */\nfunction validateConfig(config) {\n  var resolver = config.resolver;\n  if (resolver && typeof resolver !== 'function') {\n    throw new TypeError(\"Configured resolver should be a function. Got: \" + resolver);\n  }\n  return config;\n}\n/**\n * @private\n */\nfunction sanitizeConfig(config) {\n  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\n  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, constants_1.DEFAULT_POOL_MAX_SIZE);\n  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, constants_1.DEFAULT_POOL_ACQUISITION_TIMEOUT);\n  config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\n}\n/**\n * @private\n */\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\n  var sanitizedValue = parseInt(rawValue, 10);\n  if (sanitizedValue > 0 || sanitizedValue === 0) {\n    return sanitizedValue;\n  } else if (sanitizedValue < 0) {\n    return Number.MAX_SAFE_INTEGER;\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n/**\n * @private\n */\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\n  var fetchSize = parseInt(rawValue, 10);\n  if (fetchSize > 0 || fetchSize === constants_1.FETCH_ALL) {\n    return fetchSize;\n  } else if (fetchSize === 0 || fetchSize < 0) {\n    throw new Error(\"The fetch size can only be a positive value or \" + constants_1.FETCH_ALL + \" for ALL. However fetchSize = \" + fetchSize);\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n/**\n * @private\n * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.\n *              If resolved function is not specified, it defaults to an identity resolver.\n */\nfunction createHostNameResolver(config) {\n  return new configured_custom_resolver_1.default(config.resolver);\n}\nexports.default = Driver;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WRITE","READ","Driver","bookmark_1","require","connectivity_verifier_1","configured_custom_resolver_1","constants_1","logger_1","session_1","util_1","DEFAULT_MAX_CONNECTION_LIFETIME","DEFAULT_FETCH_SIZE","ACCESS_MODE_READ","ACCESS_MODE_WRITE","idGenerator","meta","config","createConnectonProvider","createSession","args","default","sanitizeConfig","validateConfig","_id","_meta","_config","_log","Logger","create","_createConnectionProvider","_createSession","_connectionProvider","_afterConstruction","prototype","verifyConnectivity","_a","_b","_c","database","connectionProvider","_getOrCreateConnectionProvider","connectivityVerifier","ConnectivityVerifier","verify","supportsMultiDb","supportsTransactionConfig","supportsUserImpersonation","_supportsRouting","routing","_isEncrypted","encrypted","ENCRYPTION_ON","_getTrust","trust","session","defaultAccessMode","bookmarkOrBookmarks","bookmarks","_d","impersonatedUser","fetchSize","_newSession","reactive","validateFetchSizeValue","close","info","Promise","resolve","typename","address","sessionMode","_validateSessionMode","bookmark","Bookmark","empty","mode","createHostNameResolver","resolver","TypeError","maxConnectionLifetime","sanitizeIntValue","maxConnectionPoolSize","DEFAULT_POOL_MAX_SIZE","connectionAcquisitionTimeout","DEFAULT_POOL_ACQUISITION_TIMEOUT","rawValue","defaultWhenAbsent","sanitizedValue","parseInt","Number","MAX_SAFE_INTEGER","FETCH_ALL","Error"],"sources":["C:/Stanford/DigitalTracesApp3/node_modules/neo4j-driver-core/lib/driver.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WRITE = exports.READ = exports.Driver = void 0;\nvar bookmark_1 = require(\"./internal/bookmark\");\nvar connectivity_verifier_1 = require(\"./internal/connectivity-verifier\");\nvar configured_custom_resolver_1 = __importDefault(require(\"./internal/resolver/configured-custom-resolver\"));\nvar constants_1 = require(\"./internal/constants\");\nvar logger_1 = require(\"./internal/logger\");\nvar session_1 = __importDefault(require(\"./session\"));\nvar util_1 = require(\"./internal/util\");\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\n/**\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\n * @type {number}\n */\nvar DEFAULT_FETCH_SIZE = 1000;\n/**\n * Constant that represents read session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\n * @type {string}\n */\nvar READ = constants_1.ACCESS_MODE_READ;\nexports.READ = READ;\n/**\n * Constant that represents write session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\n * @type {string}\n */\nvar WRITE = constants_1.ACCESS_MODE_WRITE;\nexports.WRITE = WRITE;\nvar idGenerator = 0;\n/**\n * A driver maintains one or more {@link Session}s with a remote\n * Neo4j instance. Through the {@link Session}s you can send queries\n * and retrieve results from the database.\n *\n * Drivers are reasonably expensive to create - you should strive to keep one\n * driver instance around per Neo4j Instance you connect to.\n *\n * @access public\n */\nvar Driver = /** @class */ (function () {\n    /**\n     * You should not be calling this directly, instead use {@link driver}.\n     * @constructor\n     * @protected\n     * @param {Object} meta Metainformation about the driver\n     * @param {Object} config\n     * @param {function(id: number, config:Object, log:Logger, hostNameResolver: ConfiguredCustomResolver): ConnectionProvider } createConnectonProvider Creates the connection provider\n     * @param {function(args): Session } createSession Creates the a session\n    */\n    function Driver(meta, config, createConnectonProvider, createSession) {\n        if (config === void 0) { config = {}; }\n        if (createSession === void 0) { createSession = function (args) { return new session_1.default(args); }; }\n        sanitizeConfig(config);\n        validateConfig(config);\n        this._id = idGenerator++;\n        this._meta = meta;\n        this._config = config;\n        this._log = logger_1.Logger.create(config);\n        this._createConnectionProvider = createConnectonProvider;\n        this._createSession = createSession;\n        /**\n         * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\n         * @type {ConnectionProvider}\n         * @protected\n         */\n        this._connectionProvider = null;\n        this._afterConstruction();\n    }\n    /**\n     * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\n     *\n     * @public\n     * @param {Object} param - The object parameter\n     * @param {string} param.database - The target database to verify connectivity for.\n     * @returns {Promise<ServerInfo>} promise resolved with server info or rejected with error.\n     */\n    Driver.prototype.verifyConnectivity = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.database, database = _c === void 0 ? '' : _c;\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        var connectivityVerifier = new connectivity_verifier_1.ConnectivityVerifier(connectionProvider);\n        return connectivityVerifier.verify({ database: database });\n    };\n    /**\n     * Returns whether the server supports multi database capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsMultiDb = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsMultiDb();\n    };\n    /**\n     * Returns whether the server supports transaction config capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsTransactionConfig = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsTransactionConfig();\n    };\n    /**\n     * Returns whether the server supports user impersonation capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsUserImpersonation = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsUserImpersonation();\n    };\n    /**\n     * @protected\n     * @returns {boolean}\n     */\n    Driver.prototype._supportsRouting = function () {\n        return this._meta.routing;\n    };\n    /**\n     * Returns boolean to indicate if driver has been configured with encryption enabled.\n     *\n     * @protected\n     * @returns {boolean}\n     */\n    Driver.prototype._isEncrypted = function () {\n        return this._config.encrypted === util_1.ENCRYPTION_ON;\n    };\n    /**\n     * Returns the configured trust strategy that the driver has been configured with.\n     *\n     * @protected\n     * @returns {TrustStrategy}\n     */\n    Driver.prototype._getTrust = function () {\n        return this._config.trust;\n    };\n    /**\n     * Acquire a session to communicate with the database. The session will\n     * borrow connections from the underlying connection pool as required and\n     * should be considered lightweight and disposable.\n     *\n     * This comes with some responsibility - make sure you always call\n     * {@link close} when you are done using a session, and likewise,\n     * make sure you don't close your session before you are done using it. Once\n     * it is closed, the underlying connection will be released to the connection\n     * pool and made available for others to use.\n     *\n     * @public\n     * @param {Object} param - The object parameter\n     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\n     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous\n     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\n     * @param {number} param.fetchSize - The record fetch size of each batch of this session.\n     * Use {@link FETCH_ALL} to always pull all records in one batch. This will override the config value set on driver config.\n     * @param {string} param.database - The database this session will operate on.\n     * @param {string} param.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n     * @return {Session} new session.\n     */\n    Driver.prototype.session = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultAccessMode, defaultAccessMode = _c === void 0 ? WRITE : _c, bookmarkOrBookmarks = _b.bookmarks, _d = _b.database, database = _d === void 0 ? '' : _d, impersonatedUser = _b.impersonatedUser, fetchSize = _b.fetchSize;\n        return this._newSession({\n            defaultAccessMode: defaultAccessMode,\n            bookmarkOrBookmarks: bookmarkOrBookmarks,\n            database: database,\n            reactive: false,\n            impersonatedUser: impersonatedUser,\n            fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)\n        });\n    };\n    /**\n     * Close all open sessions and other associated resources. You should\n     * make sure to use this when you are done with this driver instance.\n     * @public\n     * @return {Promise<void>} promise resolved when the driver is closed.\n     */\n    Driver.prototype.close = function () {\n        this._log.info(\"Driver \" + this._id + \" closing\");\n        if (this._connectionProvider) {\n            return this._connectionProvider.close();\n        }\n        return Promise.resolve();\n    };\n    /**\n     * @protected\n     */\n    Driver.prototype._afterConstruction = function () {\n        this._log.info(this._meta.typename + \" driver \" + this._id + \" created for server address \" + this._meta.address);\n    };\n    /**\n     * @private\n     */\n    Driver.prototype._newSession = function (_a) {\n        var defaultAccessMode = _a.defaultAccessMode, bookmarkOrBookmarks = _a.bookmarkOrBookmarks, database = _a.database, reactive = _a.reactive, impersonatedUser = _a.impersonatedUser, fetchSize = _a.fetchSize;\n        var sessionMode = session_1.default._validateSessionMode(defaultAccessMode);\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        var bookmark = bookmarkOrBookmarks\n            ? new bookmark_1.Bookmark(bookmarkOrBookmarks)\n            : bookmark_1.Bookmark.empty();\n        return this._createSession({\n            mode: sessionMode,\n            database: database || '',\n            connectionProvider: connectionProvider,\n            bookmark: bookmark,\n            config: this._config,\n            reactive: reactive,\n            impersonatedUser: impersonatedUser,\n            fetchSize: fetchSize\n        });\n    };\n    /**\n     * @private\n     */\n    Driver.prototype._getOrCreateConnectionProvider = function () {\n        if (!this._connectionProvider) {\n            this._connectionProvider = this._createConnectionProvider(this._id, this._config, this._log, createHostNameResolver(this._config));\n        }\n        return this._connectionProvider;\n    };\n    return Driver;\n}());\nexports.Driver = Driver;\n/**\n * @private\n * @returns {Object} the given config.\n */\nfunction validateConfig(config) {\n    var resolver = config.resolver;\n    if (resolver && typeof resolver !== 'function') {\n        throw new TypeError(\"Configured resolver should be a function. Got: \" + resolver);\n    }\n    return config;\n}\n/**\n * @private\n */\nfunction sanitizeConfig(config) {\n    config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\n    config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, constants_1.DEFAULT_POOL_MAX_SIZE);\n    config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, constants_1.DEFAULT_POOL_ACQUISITION_TIMEOUT);\n    config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\n}\n/**\n * @private\n */\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\n    var sanitizedValue = parseInt(rawValue, 10);\n    if (sanitizedValue > 0 || sanitizedValue === 0) {\n        return sanitizedValue;\n    }\n    else if (sanitizedValue < 0) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n    else {\n        return defaultWhenAbsent;\n    }\n}\n/**\n * @private\n */\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\n    var fetchSize = parseInt(rawValue, 10);\n    if (fetchSize > 0 || fetchSize === constants_1.FETCH_ALL) {\n        return fetchSize;\n    }\n    else if (fetchSize === 0 || fetchSize < 0) {\n        throw new Error(\"The fetch size can only be a positive value or \" + constants_1.FETCH_ALL + \" for ALL. However fetchSize = \" + fetchSize);\n    }\n    else {\n        return defaultWhenAbsent;\n    }\n}\n/**\n * @private\n * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.\n *              If resolved function is not specified, it defaults to an identity resolver.\n */\nfunction createHostNameResolver(config) {\n    return new configured_custom_resolver_1.default(config.resolver);\n}\nexports.default = Driver;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}