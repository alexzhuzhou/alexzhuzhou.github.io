{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionExecutor = void 0;\nvar error_1 = require(\"../error\");\nvar retry_strategy_1 = require(\"./retry-strategy\");\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\nvar TransactionExecutor = /** @class */function () {\n  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {\n    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\n    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\n    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n    this._inFlightTimeoutIds = [];\n    this._verifyAfterConstruction();\n  }\n  TransactionExecutor.prototype.execute = function (transactionCreator, transactionWork) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n    }).catch(function (error) {\n      var retryStartTimeMs = Date.now();\n      var retryDelayMs = _this._initialRetryDelayMs;\n      return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);\n    });\n  };\n  TransactionExecutor.prototype.close = function () {\n    // cancel all existing timeouts to prevent further retries\n    this._inFlightTimeoutIds.forEach(function (timeoutId) {\n      return clearTimeout(timeoutId);\n    });\n    this._inFlightTimeoutIds = [];\n  };\n  TransactionExecutor.prototype._retryTransactionPromise = function (transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {\n    var _this = this;\n    var elapsedTimeMs = Date.now() - retryStartTime;\n    if (elapsedTimeMs > this._maxRetryTimeMs || !(0, retry_strategy_1.canRetryOn)(error)) {\n      return Promise.reject(error);\n    }\n    return new Promise(function (resolve, reject) {\n      var nextRetryTime = _this._computeDelayWithJitter(retryDelayMs);\n      var timeoutId = setTimeout(function () {\n        // filter out this timeoutId when time has come and function is being executed\n        _this._inFlightTimeoutIds = _this._inFlightTimeoutIds.filter(function (id) {\n          return id !== timeoutId;\n        });\n        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n      }, nextRetryTime);\n      // add newly created timeoutId to the list of all in-flight timeouts\n      _this._inFlightTimeoutIds.push(timeoutId);\n    }).catch(function (error) {\n      var nextRetryDelayMs = retryDelayMs * _this._multiplier;\n      return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);\n    });\n  };\n  TransactionExecutor.prototype._executeTransactionInsidePromise = function (transactionCreator, transactionWork, resolve, reject) {\n    var _this = this;\n    var tx;\n    try {\n      tx = transactionCreator();\n    } catch (error) {\n      // failed to create a transaction\n      reject(error);\n      return;\n    }\n    var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);\n    resultPromise.then(function (result) {\n      return _this._handleTransactionWorkSuccess(result, tx, resolve, reject);\n    }).catch(function (error) {\n      return _this._handleTransactionWorkFailure(error, tx, reject);\n    });\n  };\n  TransactionExecutor.prototype._safeExecuteTransactionWork = function (tx, transactionWork) {\n    try {\n      var result = transactionWork(tx);\n      // user defined callback is supposed to return a promise, but it might not; so to protect against an\n      // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\n      // validation step without type checks\n      return Promise.resolve(result);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n  TransactionExecutor.prototype._handleTransactionWorkSuccess = function (result, tx, resolve, reject) {\n    if (tx.isOpen()) {\n      // transaction work returned resolved promise and transaction has not been committed/rolled back\n      // try to commit the transaction\n      tx.commit().then(function () {\n        // transaction was committed, return result to the user\n        resolve(result);\n      }).catch(function (error) {\n        // transaction failed to commit, propagate the failure\n        reject(error);\n      });\n    } else {\n      // transaction work returned resolved promise and transaction is already committed/rolled back\n      // return the result returned by given transaction work\n      resolve(result);\n    }\n  };\n  TransactionExecutor.prototype._handleTransactionWorkFailure = function (error, tx, reject) {\n    if (tx.isOpen()) {\n      // transaction work failed and the transaction is still open, roll it back and propagate the failure\n      tx.rollback().catch(function (ignore) {\n        // ignore the rollback error\n      }).then(function () {\n        return reject(error);\n      }); // propagate the original error we got from the transaction work\n    } else {\n      // transaction is already rolled back, propagate the error\n      reject(error);\n    }\n  };\n  TransactionExecutor.prototype._computeDelayWithJitter = function (delayMs) {\n    var jitter = delayMs * this._jitterFactor;\n    var min = delayMs - jitter;\n    var max = delayMs + jitter;\n    return Math.random() * (max - min) + min;\n  };\n  TransactionExecutor.prototype._verifyAfterConstruction = function () {\n    if (this._maxRetryTimeMs < 0) {\n      throw (0, error_1.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);\n    }\n    if (this._initialRetryDelayMs < 0) {\n      throw (0, error_1.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);\n    }\n    if (this._multiplier < 1.0) {\n      throw (0, error_1.newError)('Multiplier should be >= 1.0: ' + this._multiplier);\n    }\n    if (this._jitterFactor < 0 || this._jitterFactor > 1) {\n      throw (0, error_1.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);\n    }\n  };\n  return TransactionExecutor;\n}();\nexports.TransactionExecutor = TransactionExecutor;\nfunction _valueOrDefault(value, defaultValue) {\n  if (value || value === 0) {\n    return value;\n  }\n  return defaultValue;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TransactionExecutor","error_1","require","retry_strategy_1","DEFAULT_MAX_RETRY_TIME_MS","DEFAULT_INITIAL_RETRY_DELAY_MS","DEFAULT_RETRY_DELAY_MULTIPLIER","DEFAULT_RETRY_DELAY_JITTER_FACTOR","maxRetryTimeMs","initialRetryDelayMs","multiplier","jitterFactor","_maxRetryTimeMs","_valueOrDefault","_initialRetryDelayMs","_multiplier","_jitterFactor","_inFlightTimeoutIds","_verifyAfterConstruction","prototype","execute","transactionCreator","transactionWork","_this","Promise","resolve","reject","_executeTransactionInsidePromise","catch","error","retryStartTimeMs","Date","now","retryDelayMs","_retryTransactionPromise","close","forEach","timeoutId","clearTimeout","retryStartTime","elapsedTimeMs","canRetryOn","nextRetryTime","_computeDelayWithJitter","setTimeout","filter","id","push","nextRetryDelayMs","tx","resultPromise","_safeExecuteTransactionWork","then","result","_handleTransactionWorkSuccess","_handleTransactionWorkFailure","isOpen","commit","rollback","ignore","delayMs","jitter","min","max","Math","random","newError","defaultValue"],"sources":["C:/Stanford/DigitalTracesApp3/node_modules/neo4j-driver-core/lib/internal/transaction-executor.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionExecutor = void 0;\nvar error_1 = require(\"../error\");\nvar retry_strategy_1 = require(\"./retry-strategy\");\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\nvar TransactionExecutor = /** @class */ (function () {\n    function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {\n        this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\n        this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\n        this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n        this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n        this._inFlightTimeoutIds = [];\n        this._verifyAfterConstruction();\n    }\n    TransactionExecutor.prototype.execute = function (transactionCreator, transactionWork) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n        }).catch(function (error) {\n            var retryStartTimeMs = Date.now();\n            var retryDelayMs = _this._initialRetryDelayMs;\n            return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);\n        });\n    };\n    TransactionExecutor.prototype.close = function () {\n        // cancel all existing timeouts to prevent further retries\n        this._inFlightTimeoutIds.forEach(function (timeoutId) { return clearTimeout(timeoutId); });\n        this._inFlightTimeoutIds = [];\n    };\n    TransactionExecutor.prototype._retryTransactionPromise = function (transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {\n        var _this = this;\n        var elapsedTimeMs = Date.now() - retryStartTime;\n        if (elapsedTimeMs > this._maxRetryTimeMs || !(0, retry_strategy_1.canRetryOn)(error)) {\n            return Promise.reject(error);\n        }\n        return new Promise(function (resolve, reject) {\n            var nextRetryTime = _this._computeDelayWithJitter(retryDelayMs);\n            var timeoutId = setTimeout(function () {\n                // filter out this timeoutId when time has come and function is being executed\n                _this._inFlightTimeoutIds = _this._inFlightTimeoutIds.filter(function (id) { return id !== timeoutId; });\n                _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n            }, nextRetryTime);\n            // add newly created timeoutId to the list of all in-flight timeouts\n            _this._inFlightTimeoutIds.push(timeoutId);\n        }).catch(function (error) {\n            var nextRetryDelayMs = retryDelayMs * _this._multiplier;\n            return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);\n        });\n    };\n    TransactionExecutor.prototype._executeTransactionInsidePromise = function (transactionCreator, transactionWork, resolve, reject) {\n        var _this = this;\n        var tx;\n        try {\n            tx = transactionCreator();\n        }\n        catch (error) {\n            // failed to create a transaction\n            reject(error);\n            return;\n        }\n        var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);\n        resultPromise\n            .then(function (result) {\n            return _this._handleTransactionWorkSuccess(result, tx, resolve, reject);\n        })\n            .catch(function (error) { return _this._handleTransactionWorkFailure(error, tx, reject); });\n    };\n    TransactionExecutor.prototype._safeExecuteTransactionWork = function (tx, transactionWork) {\n        try {\n            var result = transactionWork(tx);\n            // user defined callback is supposed to return a promise, but it might not; so to protect against an\n            // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\n            // validation step without type checks\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    };\n    TransactionExecutor.prototype._handleTransactionWorkSuccess = function (result, tx, resolve, reject) {\n        if (tx.isOpen()) {\n            // transaction work returned resolved promise and transaction has not been committed/rolled back\n            // try to commit the transaction\n            tx.commit()\n                .then(function () {\n                // transaction was committed, return result to the user\n                resolve(result);\n            })\n                .catch(function (error) {\n                // transaction failed to commit, propagate the failure\n                reject(error);\n            });\n        }\n        else {\n            // transaction work returned resolved promise and transaction is already committed/rolled back\n            // return the result returned by given transaction work\n            resolve(result);\n        }\n    };\n    TransactionExecutor.prototype._handleTransactionWorkFailure = function (error, tx, reject) {\n        if (tx.isOpen()) {\n            // transaction work failed and the transaction is still open, roll it back and propagate the failure\n            tx.rollback()\n                .catch(function (ignore) {\n                // ignore the rollback error\n            })\n                .then(function () { return reject(error); }); // propagate the original error we got from the transaction work\n        }\n        else {\n            // transaction is already rolled back, propagate the error\n            reject(error);\n        }\n    };\n    TransactionExecutor.prototype._computeDelayWithJitter = function (delayMs) {\n        var jitter = delayMs * this._jitterFactor;\n        var min = delayMs - jitter;\n        var max = delayMs + jitter;\n        return Math.random() * (max - min) + min;\n    };\n    TransactionExecutor.prototype._verifyAfterConstruction = function () {\n        if (this._maxRetryTimeMs < 0) {\n            throw (0, error_1.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);\n        }\n        if (this._initialRetryDelayMs < 0) {\n            throw (0, error_1.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);\n        }\n        if (this._multiplier < 1.0) {\n            throw (0, error_1.newError)('Multiplier should be >= 1.0: ' + this._multiplier);\n        }\n        if (this._jitterFactor < 0 || this._jitterFactor > 1) {\n            throw (0, error_1.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);\n        }\n    };\n    return TransactionExecutor;\n}());\nexports.TransactionExecutor = TransactionExecutor;\nfunction _valueOrDefault(value, defaultValue) {\n    if (value || value === 0) {\n        return value;\n    }\n    return defaultValue;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}